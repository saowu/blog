<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>一个简单的Netty服务 | saowu&#39;s Blog</title>
<link rel="shortcut icon" href="https://saowu.top/blog/favicon.ico?v=1589186519758">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://saowu.top/blog/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="一个简单的Netty服务 | saowu&#39;s Blog - Atom Feed" href="https://saowu.top/blog/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">

<link rel="stylesheet" href="https://saowu.top/blog/media/live2d/css/live2d.css">




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-162711560-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-162711560-1');
</script>


    <meta name="description" content="
在网络编程领域，Netty是Java的卓越框架。它驾驭了Java高级API的能力，并将其隐藏在一个易于使用的API之后。Netty使你可以专注于自己真正感兴趣的——你的应用程序的独一无二的价值。---《Netty实战》

一、Java I..." />
    <meta name="keywords" content="Java" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://saowu.top/blog">
  <img class="avatar" src="https://saowu.top/blog/images/avatar.png?v=1589186519758" alt="">
  </a>
  <h1 class="site-title">
    saowu&#39;s Blog
  </h1>
  <p class="site-description">
    A programmer who wants to be happy and muddle along
  </p>
  <div class="menu-container">
    
      
        <a href="/blog" class="menu">
          首页
        </a>
      
    
      
        <a href="/blog/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/blog/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/blog/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://saowu.top/reptiles/nCoV_map.html" class="menu">
          nCoV肺炎
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/saowu" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
        <a href="https://weibo.com/u/6635817704" target="_blank">
          <i class="ri-weibo-line"></i>
        </a>
      
    
      
        <a href="https://www.zhihu.com/people/43703339aec7960c1020ba061888a016" target="_blank">
          <i class="ri-zhihu-line"></i>
        </a>
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              <!-- 生成海报 -->
              <a target="_blank" href="https://saowu.top/recommend/bill.html?title=一个简单的Netty服务">
                一个简单的Netty服务
              </a>
            </h2>
            <div class="post-info">
              <span>
                2020-04-30
              </span>
              <span>
                12 min read
              </span>
              
                <a href="https://saowu.top/blog/FWHSehn5o/" class="post-tag">
                  # Java
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://saowu.top/blog/post-images/vj24Wlw0f.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <blockquote>
<p>在网络编程领域，Netty是Java的卓越框架。它驾驭了Java高级API的能力，并将其隐藏在一个易于使用的API之后。Netty使你可以专注于自己真正感兴趣的——你的应用程序的独一无二的价值。---《Netty实战》</p>
</blockquote>
<h2 id="一-java-io模型">一、Java IO模型</h2>
<h3 id="1同步阻塞-io模型bio">1.同步阻塞 I/O模型（BIO）</h3>
<ul>
<li><code>BIO (Blocking I/O)</code>: 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li>
</ul>
<h3 id="2同步非阻塞-io模型-nio">2.同步非阻塞 I/O模型 （NIO）</h3>
<ul>
<li><code>NIO (Non-blocking/New I/O)</code>: NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。</li>
</ul>
<h3 id="3异步非阻塞-io模型-aio">3.异步非阻塞 I/O模型 （AIO）</h3>
<ul>
<li><code>AIO (Asynchronous I/O)</code>: AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li>
</ul>
<h2 id="二-netty简介">二、 Netty简介</h2>
<p>Netty是一款基于NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架，擅长高负载下可靠和高效地处理和调度 I/O 操作。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>Netty 的特性</th>
</tr>
</thead>
<tbody>
<tr>
<td>设计</td>
<td>统一的 API，支持多种传输类型，阻塞的和非阻塞的； 简单而强大的线程模型；真正的无连接数据报套接字支持； 链接逻辑组件以支持复用</td>
</tr>
<tr>
<td>易于使用</td>
<td>详实的Javadoc和大量的示例集；不需要超过JDK 1.6+的依赖(一些可选的特性可能需要Java 1.7+或额外的依赖)</td>
</tr>
<tr>
<td>性能</td>
<td>拥有比 Java 的核心 API 更高的吞吐量以及更低的延迟；得益于池化和复用，拥有更低的资源消耗； 最少的内存复制</td>
</tr>
<tr>
<td>健壮性</td>
<td>不会因为慢速、快速或者超载的连接而导致 OutOfMemoryError 消除在高速网络中 NIO 应用程序常见的不公平读/写比率</td>
</tr>
<tr>
<td>安全性</td>
<td>完整的 SSL/TLS 以及 StartTLS 支持； 可用于受限环境下，如 Applet 和 OSGI</td>
</tr>
<tr>
<td>社区驱动</td>
<td>发布快速而且频繁</td>
</tr>
</tbody>
</table>
<h2 id="三-netty基础组件">三、Netty基础组件</h2>
<ul>
<li><code>Channel</code>：Channel 是 Java NIO 的一个基本构造。它代表一个到实体(如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的I/O操作的程序组件)的开放连接，如读操作和写操作。</li>
<li><code>回调</code>：一个回调其实就是一个方法，一个指向已经被提供给另外一个方法的方法的引用。这使得后者可以在适当的时候调用前者。</li>
<li><code>Future</code>：Future 提供了另一种在操作完成时通知应用程序的方式。这个对象可以看作是一个异步操 作的结果的占位符;它将在未来的某个时刻完成，并提供对其结果的访问。</li>
<li><code>事件和 ChannelHandler</code>：Netty 使用不同的事件来通知我们状态的改变或者是操作的状态。这使得我们能够基于已经发生的事件来触发适当的动作。每个事件都可以被分发给 ChannelHandler 类中的某个用户实现的方法。</li>
</ul>
<h2 id="四-创建第一个netty服务">四、创建第一个Netty服务</h2>
<h3 id="1客户端和服务器结构">1.客户端和服务器结构</h3>
<figure data-type="image" tabindex="1"><img src="https://saowu.top/blog/post-images/1588227485171.png" alt="" loading="lazy"></figure>
<ul>
<li>服务器的主要代码组件:
<ul>
<li>EchoServerHandler 实现了业务逻辑;</li>
<li>EchoServer引导过程：
<ul>
<li>创建一个 ServerBootstrap 的实例以引导和绑定服务器;</li>
<li>创建并分配一个 NioEventLoopGroup 实例以进行事件的处理，如接受新连接以及读/写数据;</li>
<li>指定服务器绑定的本地的 InetSocketAddress;</li>
<li>使用一个 EchoServerHandler 的实例初始化每一个新的 Channel;</li>
<li>调用 ServerBootstrap.bind()方法以绑定服务器。</li>
</ul>
</li>
</ul>
</li>
<li>客户端的主要代码组件:
<ul>
<li>EchoClientHandler 实现了业务逻辑;</li>
<li>EchoClient引导过程：
<ul>
<li>为初始化客户端，创建了一个 Bootstrap 实例;</li>
<li>为进行事件处理分配了一个 NioEventLoopGroup 实例，其中事件处理包括创建新的连接以及处理入站和出站数据;</li>
<li>为服务器连接创建了一个 InetSocketAddress 实例;</li>
<li>当连接被建立时，一个 EchoClientHandler 实例会被安装到(该Channel的）ChannelPipeline 中;</li>
<li>在一切都设置完成后，调用 Bootstrap.connect()方法连接到远程节点；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2在pomxml添加如下代码">2.在pom.xml添加如下代码</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;io.netty&lt;/groupId&gt;
    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;
    &lt;version&gt;4.1.42.Final&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="3创建服务端channelhandler实现类">3.创建服务端ChannelHandler实现类</h3>
<pre><code class="language-java">package org.example.netty.server;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelFutureListener;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.util.CharsetUtil;

/**
 * 响应入站事件，实现了服务器对从客户端接收的数据的处理，即它的业务逻辑
 */

@ChannelHandler.Sharable //标示一个 ChannelHandler 可以被多 个 Channel 安全地 共享
public class EchoServerHandler extends ChannelInboundHandlerAdapter {
    /**
     * 对于每个传入的消息都要调用该方法
     *
     * @param ctx
     * @param msg
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ByteBuf in = (ByteBuf) msg;
        System.out.println(&quot;Server received: &quot; + in.toString(CharsetUtil.UTF_8));
        //将接收到的消息 写给发送者，而不冲刷出站消息
        ctx.write(in);
    }

    /**
     * 通知ChannelInboundHandler最后一次对channelRead()
     * 的调用是当前批量读取中的最后一条消息
     *
     * @param ctx
     */
    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) {
        // 将未决消息冲刷到远程节点，并且关闭该Channel
        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);
    }

    /**
     * 在读取操作期间，有异常抛出时会调用
     *
     * @param ctx
     * @param cause
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        // 关闭该Channel
        ctx.close();
    }
}

</code></pre>
<h3 id="4-创建服务端引导">4. 创建服务端引导</h3>
<pre><code class="language-java">package org.example.netty.server;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;

import java.net.InetSocketAddress;

/**
 * 配置服务器的启动代码，将服务器绑定到它要监听连接请求的端口上
 */
public class EchoServer {
    private final int port;

    public EchoServer(int port) {
        this.port = port;
    }

    public void start() throws Exception {
        final EchoServerHandler serverHandler = new EchoServerHandler();
        //创建 EventLoopGroup
        EventLoopGroup group = new NioEventLoopGroup();
        try {
            // 创建 ServerBootstrap
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap.group(group)
                    .channel(NioServerSocketChannel.class)//指定所使用的 NIO 传输 Channel
                    .localAddress(new InetSocketAddress(port))//使用指定的 端口设置套 接字地址
                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {// 添加一个 EchoServerHandler 到子 Channel 的 ChannelPipeline
                        @Override
                        public void initChannel(SocketChannel ch) {
                            // EchoServerHandler 被标注为@Shareable，所以我们可以总是使用同样的实例
                            ch.pipeline().addLast(serverHandler);
                        }
                    });
            //异步地绑定服务器; 调用 sync()方法阻塞 等待直到绑定完成
            ChannelFuture future = serverBootstrap.bind().sync();
            //获取 Channel 的 CloseFuture，并且阻塞当前线程直到它完成
            future.channel().closeFuture().sync();
        } finally {
            // 关闭 EventLoopGroup， 释放所有的资源
            group.shutdownGracefully().sync();
        }
    }

}

</code></pre>
<h3 id="5创建客户端channelhandler实现类">5.创建客户端ChannelHandler实现类</h3>
<pre><code class="language-java">package org.example.netty.client;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.util.CharsetUtil;

/**
 * 用来处理数据的ClientHandler
 */
@ChannelHandler.Sharable
public class EchoClientHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; {
    /**
     * 在到服务器的连接已经建立之后将被调用
     *
     * @param ctx
     */
    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        //当被通知 Channel 是活跃的时候，发送一条消息
        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;Hello Netty!&quot;, CharsetUtil.UTF_8));
    }

    /**
     * 当从服务器接收到一条消息时被调用
     *
     * @param ctx
     * @param in
     */
    @Override
    public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) {
        System.out.println(&quot;Client received: &quot; + in.toString(CharsetUtil.UTF_8));
    }

    /**
     * 在处理过程中引发异常时被调用
     * 在发生异常时， 记录错误并关闭 Channel
     *
     * @param ctx
     * @param cause
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }
}
</code></pre>
<h3 id="6创建客户端引导">6.创建客户端引导</h3>
<pre><code class="language-java">package org.example.netty.client;

import io.netty.bootstrap.Bootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;

import java.net.InetSocketAddress;

public class EchoClient {
    private final String host;
    private final int port;

    public EchoClient(String host, int port) {
        this.host = host;
        this.port = port;
    }

    public void start() throws Exception {
        EventLoopGroup group = new NioEventLoopGroup();
        try {
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.group(group)
                    .channel(NioSocketChannel.class)
                    .remoteAddress(new InetSocketAddress(host, port))
                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() {
                        @Override
                        protected void initChannel(SocketChannel channel) {
                            channel.pipeline()
                                    .addLast(new EchoClientHandler());
                        }
                    });
            ChannelFuture future = bootstrap.connect().sync();
            future.channel().closeFuture().sync();
        } finally {
            group.shutdownGracefully().sync();
        }
    }
}

</code></pre>
<h3 id="7创建cs启动类">7.创建C/S启动类</h3>
<pre><code class="language-java">package org.example;

import org.example.netty.client.EchoClient;
import org.example.netty.server.EchoServer;

/**
 * ServerRun
 */
public class ServerRun {
    public static void main(String[] args) throws Exception {
        System.err.println(&quot;Usage: &quot; + EchoServer.class.getSimpleName() + &quot; 9000&quot;);
        new EchoServer(9000).start();
    }
}

</code></pre>
<pre><code class="language-java">package org.example;

import org.example.netty.client.EchoClient;
import org.example.netty.server.EchoServer;

/**
 * ClientRun
 */
public class ClientRun {
    public static void main(String[] args) throws Exception {
        System.err.println(&quot;Usage: &quot; + EchoClient.class.getSimpleName() + &quot; 127.0.0.1:9000&quot;);
        new EchoClient(&quot;127.0.0.1&quot;, 9000).start();
    }
}
</code></pre>
<h2 id="五-执行success">五、执行Success！</h2>
<pre><code>/Library/Java/JavaVirtualMachines/jdk-11.0.6.jdk/Contents/Home/bin/java &quot;-javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=57884:/Applications/IntelliJ IDEA.app/Contents/bin&quot; -Dfile.encoding=UTF-8 -classpath /Users/saowu/Documents/IdeaProjects/netty_demo/target/classes:/Users/saowu/.m2/repository/io/netty/netty-all/4.1.42.Final/netty-all-4.1.42.Final.jar org.example.ClientRun
Usage: EchoClient 127.0.0.1:9000
Client received: Hello Netty!

Process finished with exit code 0
</code></pre>
<pre><code>/Library/Java/JavaVirtualMachines/jdk-11.0.6.jdk/Contents/Home/bin/java &quot;-javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=57880:/Applications/IntelliJ IDEA.app/Contents/bin&quot; -Dfile.encoding=UTF-8 -classpath /Users/saowu/Documents/IdeaProjects/netty_demo/target/classes:/Users/saowu/.m2/repository/io/netty/netty-all/4.1.42.Final/netty-all-4.1.42.Final.jar org.example.ServerRun
Usage: EchoServer 9000
Server received: Hello Netty!

</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-java-io%E6%A8%A1%E5%9E%8B">一、Java IO模型</a>
<ul>
<li><a href="#1%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E-io%E6%A8%A1%E5%9E%8Bbio">1.同步阻塞 I/O模型（BIO）</a></li>
<li><a href="#2%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E-io%E6%A8%A1%E5%9E%8B-nio">2.同步非阻塞 I/O模型 （NIO）</a></li>
<li><a href="#3%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E-io%E6%A8%A1%E5%9E%8B-aio">3.异步非阻塞 I/O模型 （AIO）</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C-netty%E7%AE%80%E4%BB%8B">二、 Netty简介</a></li>
<li><a href="#%E4%B8%89-netty%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6">三、Netty基础组件</a></li>
<li><a href="#%E5%9B%9B-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAnetty%E6%9C%8D%E5%8A%A1">四、创建第一个Netty服务</a>
<ul>
<li><a href="#1%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E6%9E%84">1.客户端和服务器结构</a></li>
<li><a href="#2%E5%9C%A8pomxml%E6%B7%BB%E5%8A%A0%E5%A6%82%E4%B8%8B%E4%BB%A3%E7%A0%81">2.在pom.xml添加如下代码</a></li>
<li><a href="#3%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E7%AB%AFchannelhandler%E5%AE%9E%E7%8E%B0%E7%B1%BB">3.创建服务端ChannelHandler实现类</a></li>
<li><a href="#4-%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%95%E5%AF%BC">4. 创建服务端引导</a></li>
<li><a href="#5%E5%88%9B%E5%BB%BA%E5%AE%A2%E6%88%B7%E7%AB%AFchannelhandler%E5%AE%9E%E7%8E%B0%E7%B1%BB">5.创建客户端ChannelHandler实现类</a></li>
<li><a href="#6%E5%88%9B%E5%BB%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%95%E5%AF%BC">6.创建客户端引导</a></li>
<li><a href="#7%E5%88%9B%E5%BB%BAcs%E5%90%AF%E5%8A%A8%E7%B1%BB">7.创建C/S启动类</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94-%E6%89%A7%E8%A1%8Csuccess">五、执行Success！</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://saowu.top/blog/pml_ecDtV/">
              <h3 class="post-title">
                hashCode()与equals()
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1ffeeefba638614e6e82',
    clientSecret: 'a43973f705103d89ba604087f510cb19bc3ac204',
    repo: 'blog',
    owner: 'saowu',
    admin: ['saowu'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        
<div class="site-footer">
  <p>Copyright 2020 saowu</p>
<p>Any and all opinions listed here are my own and not representative of my employers; future, past and present.</p>


  <a class="rss" href="https://saowu.top/blog/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

<div id="landlord" style="left:5px;bottom:0px;">
    <div class="message" style="opacity:0"></div>
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
            <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off" placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
            <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off" placeholder="要和我聊什么呀？"/>
            <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
    </div>
    <input name="live_talk" id="live_talk" value="1" type="hidden" />
    <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        <div class="live_ico_item type_music" id="musicButton"></div>
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input name="live2dBGM" value="/blog/media/saowu.mp3" type="hidden">
        <input id="duType" value="douqilai,l2d_caihong" type="hidden">
    </div>
</div>
<div id="open_live2d">召唤伊斯特瓦尔</div>
<script>
    var message_Path = '/blog/media/live2d/';//资源目录，如果目录不对请更改
    var talkAPI = "";//如果有类似图灵机器人的聊天接口请填写接口路径
</script>

<script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script type="text/javascript" src="/blog/media/live2d/js/live2d.js"></script>
<script type="text/javascript" src="/blog/media/live2d/js/message.js"></script>
      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
