<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>JVM垃圾收集策略 | saowu&#39;s Blog</title>
<link rel="shortcut icon" href="https://saowu.top/blog/favicon.ico?v=1587353068945">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://saowu.top/blog/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="JVM垃圾收集策略 | saowu&#39;s Blog - Atom Feed" href="https://saowu.top/blog/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">

<link rel="stylesheet" href="https://saowu.top/blog/media/live2d/css/live2d.css">




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-162711560-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-162711560-1');
</script>


    <meta name="description" content="
相比C++，java做的一大改进是将复杂的内存管理抽离出来交给jvm去处理，让不再时刻盯着内存泄漏的问题，可以更专注于业务逻辑的开发。这样一来，设计一个合适的垃圾回收算法是很重要的。

一、再谈引用
JDK1.2以后，Java对引用的概念..." />
    <meta name="keywords" content="Java" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://saowu.top/blog">
  <img class="avatar" src="https://saowu.top/blog/images/avatar.png?v=1587353068945" alt="">
  </a>
  <h1 class="site-title">
    saowu&#39;s Blog
  </h1>
  <p class="site-description">
    A programmer who wants to be happy and muddle along
  </p>
  <div class="menu-container">
    
      
        <a href="/blog" class="menu">
          首页
        </a>
      
    
      
        <a href="/blog/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/blog/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/blog/about" class="menu">
          关于
        </a>
      
    
      
        <a href="https://saowu.top/reptiles/nCoV_map.html" class="menu">
          nCoV肺炎
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/saowu" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
        <a href="https://weibo.com/u/6635817704" target="_blank">
          <i class="ri-weibo-line"></i>
        </a>
      
    
      
        <a href="https://www.zhihu.com/people/43703339aec7960c1020ba061888a016" target="_blank">
          <i class="ri-zhihu-line"></i>
        </a>
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              JVM垃圾收集策略
            </h2>
            <div class="post-info">
              <span>
                2020-04-19
              </span>
              <span>
                6 min read
              </span>
              
                <a href="https://saowu.top/blog/FWHSehn5o/" class="post-tag">
                  # Java
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://saowu.top/blog/post-images/Uy_GlAH_u.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <blockquote>
<p>相比C++，java做的一大改进是将复杂的内存管理抽离出来交给jvm去处理，让不再时刻盯着内存泄漏的问题，可以更专注于业务逻辑的开发。这样一来，设计一个合适的垃圾回收算法是很重要的。</p>
</blockquote>
<h2 id="一-再谈引用">一、再谈引用</h2>
<p>JDK1.2以后，Java对引用的概念进行了扩充，将引用分为<code>强引用</code>、<code>软引用</code>、<code>弱引用</code>、<code>虚引用</code>4种，这4种引用强弱逐渐减弱。</p>
<ul>
<li><strong>强引用</strong>就是指在程序代码之中普遍存在的，类似<code>Object object = new Object()</code>这类的引用，只要强引用还在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li><strong>软引用</strong>是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供的<code>SoftReference</code>类来实现软引用。</li>
<li><strong>弱引用</strong>也是用来描述非必需对象的，但它比软引用的引用强度更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供的<code>WeakReference</code>类来实现弱引用。</li>
<li><strong>虚引用</strong>也被称为幽灵引用或幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时能收到一个系统通知。在JDK1.2之后，提供的<code>PhantomReference</code>类来实现虚引用。</li>
</ul>
<h2 id="二-可达性分析算法">二、可达性分析算法</h2>
<p>这种算法的思路在于：将一系列被称为GC Roots的变量作为初始的存活对象合集，然后从该合集出发，所有能够被该集合引用到的对象，并将其加入到该集合中，而不能被该合集所引用到的对象，并可对其宣告死亡。</p>
<p>一般而言，GC Roots 是一些由堆外指向堆内的引用，包括如下几种：</p>
<ul>
<li>虚拟机栈（栈帧中的局部变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象<br>
<img src="https://saowu.top/blog/post-images/1587278843915.png" alt="" loading="lazy"></li>
</ul>
<h2 id="三-生存还是死亡">三、生存还是死亡</h2>
<p>要真正宣告一个对象的死亡，至少需要经历两次标记过程：</p>
<ul>
<li>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code> 方法。当对象没有覆盖<code>finalize()</code> 方法，或者<code>finalize()</code> 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</li>
<li>如果这个对象被判定为有必要执行<code>finalize()</code> 方法，那么这个对象将会放置在一个<code>F-Queue</code>队列中，稍后会有一个<code>Finalizer</code>线程去执行它。GC将对<code>F-Queue</code>队列中的对象进行第二次标记，在这之前，只要重新和任何一个对象建立关联就可以拯救自己，将在第二次标记时被移除“即将回收”的集合。</li>
</ul>
<h2 id="四-垃圾收集算法">四、垃圾收集算法</h2>
<h3 id="41-标记-清除mark-sweep算法">4.1 标记-清除（Mark-Sweep）算法</h3>
<p>该算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记对象。</p>
<ul>
<li>该算法的不足：
<ul>
<li>效率不足：标记和清除两个过程效率都不高。</li>
<li>空间问题：标记清除后会产生大量不连续的内存碎片。<br>
<img src="https://saowu.top/blog/post-images/1587273667745.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h3 id="42-复制copying算法">4.2 复制（Copying）算法</h3>
<p>为了解决效率问题，复制算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整半块内存进行回收，不必考虑内存碎片问题。</p>
<ul>
<li>该算法的不足：
<ul>
<li>将内存缩小为了原来的一半，浪费50%内存。</li>
<li>对象存活率较高时就要进行较多的复制操作，效率会降低。<br>
<img src="https://saowu.top/blog/post-images/1587276075342.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h3 id="43-标记-整理mark-compact算法">4.3 标记-整理（Mark-Compact）算法</h3>
<p>该算法标记过程和“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有对象都向一端移动，然后清理掉端边界以外的内存。</p>
<ul>
<li>该算法的不足：
<ul>
<li>对象存活率较高时就要进行较多的移动操作，效率会降低。<br>
<img src="https://saowu.top/blog/post-images/1587276608278.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h3 id="44-分代收集generational-collection算法">4.4 分代收集（Generational Collection）算法</h3>
<p>该算法没有什么新的思想，只是根据对象存活周期的不同划分为几块。一般是把Java堆分为新生代（Yong）和老年代（Old），这样就可以根据各个年代的特点采用最适宜的收集算法。</p>
<ul>
<li>例如：
<ul>
<li>新生代中，每次垃圾回收都有大量对象死去，只有少量存活，那就选用复制算法。</li>
<li>老年代中，因为对象存活率高、没有额外空间进行分配，就可以选用“标记-清理”或者“标记-整理”算法。</li>
</ul>
</li>
</ul>
<h3 id="附-jvm内存布局">附： JVM内存布局</h3>
<figure data-type="image" tabindex="1"><img src="https://saowu.top/blog/post-images/1586178611304.jpg" alt="image" loading="lazy"></figure>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%80-%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8">一、再谈引用</a></li>
<li><a href="#%E4%BA%8C-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95">二、可达性分析算法</a></li>
<li><a href="#%E4%B8%89-%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1">三、生存还是死亡</a></li>
<li><a href="#%E5%9B%9B-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95">四、垃圾收集算法</a>
<ul>
<li><a href="#41-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4mark-sweep%E7%AE%97%E6%B3%95">4.1 标记-清除（Mark-Sweep）算法</a></li>
<li><a href="#42-%E5%A4%8D%E5%88%B6copying%E7%AE%97%E6%B3%95">4.2 复制（Copying）算法</a></li>
<li><a href="#43-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86mark-compact%E7%AE%97%E6%B3%95">4.3 标记-整理（Mark-Compact）算法</a></li>
<li><a href="#44-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86generational-collection%E7%AE%97%E6%B3%95">4.4 分代收集（Generational Collection）算法</a></li>
<li><a href="#%E9%99%84-jvm%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80">附： JVM内存布局</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://saowu.top/blog/5YTZFZvie/">
              <h3 class="post-title">
                用python写一个新冠疫情爬虫
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '1ffeeefba638614e6e82',
    clientSecret: 'a43973f705103d89ba604087f510cb19bc3ac204',
    repo: 'blog',
    owner: 'saowu',
    admin: ['saowu'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  <p>Copyright 2020 saowu</p>
<p>Any and all opinions listed here are my own and not representative of my employers; future, past and present.</p>
  <a class="rss" href="https://saowu.top/blog/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

<div id="landlord" style="left:5px;bottom:0px;">
    <div class="message" style="opacity:0"></div>
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
            <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off" placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
            <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off" placeholder="要和我聊什么呀？"/>
            <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
    </div>
    <input name="live_talk" id="live_talk" value="1" type="hidden" />
    <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        <div class="live_ico_item type_music" id="musicButton"></div>
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input name="live2dBGM" value="/blog/media/saowu.mp3" type="hidden">
        <input id="duType" value="douqilai,l2d_caihong" type="hidden">
    </div>
</div>
<div id="open_live2d">召唤伊斯特瓦尔</div>
<script>
    var message_Path = '/blog/media/live2d/';//资源目录，如果目录不对请更改
    var talkAPI = "";//如果有类似图灵机器人的聊天接口请填写接口路径
</script>

<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
<script type="text/javascript" src="/blog/media/live2d/js/live2d.js"></script>
<script type="text/javascript" src="/blog/media/live2d/js/message.js"></script>
      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
