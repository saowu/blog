<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://saowu.github.io/blog</id>
    <title>saowu&apos;s Blog</title>
    <updated>2020-04-07T01:04:59.658Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://saowu.github.io/blog"/>
    <link rel="self" href="https://saowu.github.io/blog/atom.xml"/>
    <subtitle>A programmer who wants to be happy and muddle along</subtitle>
    <logo>https://saowu.github.io/blog/images/avatar.png</logo>
    <icon>https://saowu.github.io/blog/favicon.ico</icon>
    <rights>All rights reserved 2020, saowu&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[让Google搜索到GitHub Pages]]></title>
        <id>https://saowu.github.io/blog/4tCVcic30/</id>
        <link href="https://saowu.github.io/blog/4tCVcic30/">
        </link>
        <updated>2020-04-04T12:55:35.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>免费的东西自然是越香越好啊</p>
</blockquote>
<h2 id="一-查看是否被收录">一、查看是否被收录</h2>
<ul>
<li>首先查看你的博客地址是否已经被Google收录，在Google的搜索栏中搜索：<code>site:https://xxxx.github.io</code>，其中https://xxxx.github.io为你的博客地址，如果结果是尝试使用Google Search Console，则意味着没有被收录。</li>
</ul>
<p><em>如果搜索出你想要的结果，那么不用继续往下看了。</em></p>
<h2 id="二-搜索资源提交">二、搜索资源提交</h2>
<ul>
<li>
<p>进入Google Web Master，点击： <a href="https://search.google.com/search-console?hl=zh-CN&amp;utm_source=wmx&amp;utm_medium=deprecation-pane&amp;utm_content=home&amp;resource_id=https://saowu.github.io/">Google Search Console</a>（若未登录谷歌账号，需要先登录谷歌账号）</p>
</li>
<li>
<p>点击<code>网址前缀</code>添加（网域方式验证方式单一），提交你的博客网址，然后跳转到如下界面进行验证。<br>
<img src="https://saowu.github.io/blog/post-images/1586005315008.png" alt="" loading="lazy"></p>
</li>
<li>
<p>验证方式有一下几种，根据实际情况，按要求验证即可。</p>
<ul>
<li>将 HTML 文件上传至您的网站<br>
<img src="https://saowu.github.io/blog/post-images/1586005851160.png" alt="" loading="lazy"></li>
<li>向您网站的首页添加元标记<br>
<img src="https://saowu.github.io/blog/post-images/1586006930652.png" alt="" loading="lazy"></li>
<li>使用您的 Google 跟踪代码管理器帐号<br>
<img src="https://saowu.github.io/blog/post-images/1586005886077.png" alt="" loading="lazy"></li>
<li>将 DNS 记录与 Google 关联<br>
<img src="https://saowu.github.io/blog/post-images/1586005899681.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h2 id="三-添加站点地图">三、添加站点地图</h2>
<p>站点地图(Site Map)是用来注明网站结构的文件，我们希望搜索引擎的爬虫了解我们的网站结构,以便于高效爬取内容，快速建立索引。</p>
<ul>
<li>点击进入 <a href="https://www.xml-sitemaps.com/">XML-Sitemaps.com</a> 页面，输入博客地址，点击 start。<br>
<img src="https://saowu.github.io/blog/post-images/1586006006506.png" alt="" loading="lazy"></li>
<li>等待搜索完成，点击 VIEW SITEMAP DETAILS。<br>
<img src="https://saowu.github.io/blog/post-images/1586006110505.png" alt="" loading="lazy"></li>
<li>下载 SITEMAP 文件sitemap.xml并将其上传到网站的根目录。<br>
<img src="https://saowu.github.io/blog/post-images/1586006133718.png" alt="" loading="lazy"></li>
<li>在 Google Search console 中添加你的 sitemap URL。
<ul>
<li>还是刚刚的Google Search Console网站，点击刚刚验证成功的你的网站进入控制台，在左边侧边栏“抓取”下找到“站点地图”,将https://xxxx.github.io/sitemap.xml提交并刷新，就可以看到博客的网站结构了。<br>
<img src="https://saowu.github.io/blog/post-images/1586006241464.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h2 id="四-手动提交google抓取可选">四、手动提交Google抓取（可选）</h2>
<ul>
<li>等待Google抓取所需时间比较长，可以利用Google网页检查工具手动提交网址。（不是必须，等待Gooogle自行抓取也是可以的）<br>
<img src="https://saowu.github.io/blog/post-images/1586006394550.png" alt="" loading="lazy"></li>
<li>等待片刻后，网页检查结果就会出来了，接下来点击请求编入索引即可。<br>
<img src="https://saowu.github.io/blog/post-images/1586006475987.png" alt="" loading="lazy"></li>
</ul>
<h2 id="五-google收录成功">五、Google收录成功</h2>
<figure data-type="image" tabindex="1"><img src="https://saowu.github.io/blog/post-images/1586006635125.png" alt="" loading="lazy"></figure>
<p>更新自<a href="https://evanli.github.io/blog/2018/10/25/let-jekyll-github-pages-be-searched-by-google/">EvanLi的博客</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker安装MySQL]]></title>
        <id>https://saowu.github.io/blog/xjJ08KIvI/</id>
        <link href="https://saowu.github.io/blog/xjJ08KIvI/">
        </link>
        <updated>2020-04-04T08:04:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>操作容器的快乐，一般人都能体会到，没错你就是一般人。</p>
</blockquote>
<h2 id="一-检索mysql容器">一、检索mysql容器</h2>
<pre><code>docker search mysql
</code></pre>
<h2 id="二-拉取mysql容器镜像">二、拉取mysql容器镜像</h2>
<pre><code>docker pull mysql:latest
</code></pre>
<h2 id="三-查看全部容器镜像">三、查看全部容器镜像</h2>
<pre><code>docker images
</code></pre>
<h2 id="四-运行镜像生成容器">四、运行镜像生成容器</h2>
<ul>
<li>-p &lt;宿主机port：容器port&gt;</li>
<li>-d &lt;镜像名：版本&gt;</li>
<li>--name &lt;容器别名&gt;</li>
</ul>
<pre><code>docker run --name mysql1 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest
</code></pre>
<h2 id="五-查看全部容器">五、查看全部容器</h2>
<pre><code>docker ps -a
</code></pre>
<h2 id="六-进入容器">六、进入容器</h2>
<ul>
<li>-i :即使没有附加也保持STDIN 打开</li>
<li>-t :分配一个伪终端 <code>/bin/bash</code></li>
</ul>
<pre><code>docker exec -i -t mysql1 /bin/bash
</code></pre>
<h2 id="七-登陆mysql">七、登陆mysql</h2>
<pre><code>mysql -u root -p
</code></pre>
<h2 id="八-修改为root-可以通过任何客户端连接">八、修改为root 可以通过任何客户端连接</h2>
<pre><code>use mysql
ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456';
</code></pre>
<h2 id="九-修改数据库中文乱码">九、修改数据库中文乱码</h2>
<pre><code>show variables like 'character%';
set character_set_database = 'utf8';
set character_set_server = 'utf8';
</code></pre>
<h2 id="十-远程链接success">十、远程链接Success!</h2>
<figure data-type="image" tabindex="1"><img src="https://saowu.github.io/blog/post-images/1585989623761.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker for Mac安装设置]]></title>
        <id>https://saowu.github.io/blog/u7TQyhZuR/</id>
        <link href="https://saowu.github.io/blog/u7TQyhZuR/">
        </link>
        <updated>2020-04-04T07:29:05.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>2019年后的Desktop版和以前的UI不太一样，接下来教你设置新版Docker Desktop for Mac镜像加速。</p>
</blockquote>
<h3 id="一-下载并安装">一、下载并安装</h3>
<p>👉<a href="https://download.docker.com/mac/stable/Docker.dmg">Download for Mac</a></p>
<h3 id="二-设置镜像加速">二、设置镜像加速</h3>
<ul>
<li>这里用的是<a href="https://www.aliyun.com/">阿里云</a>的<code>容器镜像服务</code>,如果没有账号需要先注册一下。<br>
<img src="https://saowu.github.io/blog/post-images/1585986280355.jpeg" alt="" loading="lazy"><br>
<img src="https://saowu.github.io/blog/post-images/1585986397453.png" alt="" loading="lazy"></li>
</ul>
<h3 id="三-启动并配置docekr">三、启动并配置Docekr</h3>
<ul>
<li>右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Docker Engine 标签下的 Registry mirrors 列表中将https://******.mirror.aliyuncs.com加到registry-mirrors&quot;的数组里，点击 Apply &amp; Restart按钮，等待Docker重启并应用配置的镜像加速器。</li>
</ul>
<pre><code class="language-json">{
  &quot;experimental&quot;: false,
  &quot;debug&quot;: true,
  &quot;registry-mirrors&quot;: [
    &quot;https://******.mirror.aliyuncs.com&quot;
  ]
}
</code></pre>
<p><img src="https://saowu.github.io/blog/post-images/1585986703232.png" alt="" loading="lazy"><br>
<img src="https://saowu.github.io/blog/post-images/1585986710051.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[What is docker ？]]></title>
        <id>https://saowu.github.io/blog/yadpkA34H/</id>
        <link href="https://saowu.github.io/blog/yadpkA34H/">
        </link>
        <updated>2020-04-04T06:57:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>据“咳咳咳”学统计，学会了Docker你可以少死去好几百万只手也数不过来的脑细胞。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://saowu.github.io/blog/post-images/1585984531665.png" alt="" loading="lazy"></figure>
<h2 id="docker是什么">Docker是什么？</h2>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以以统一的方式打包他们的应用以及依赖包到一个可移植的<code>容器</code>中，然后发布到任何安装了docker引擎的服务器上（包括流行的Linux机器、windows机器），也可以实现虚拟化。</li>
</ul>
<h2 id="docker-核心概念">Docker 核心概念</h2>
<ul>
<li>Docker 中有三个核心概念：<code>Image</code>、<code>Container</code>、<code>Repository</code>。</li>
</ul>
<h3 id="容器">容器</h3>
<ul>
<li>容器（Container）是打包代码及其所有依赖项的标准软件单元，因此应用程序可以从一个计算环境快速可靠地运行到另一个计算环境。容器的存在离不开镜像的支持，他是镜像运行时的一个载体（类似于实例和类的关系）。依托 Docker 的虚拟化技术，给容器创建了独立的端口、进程、文件等“空间”，Container 就是一个与宿机隔离 “容器”。容器可宿主机之间可以进行 port、volumes、network 等的通信。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低</li>
</ul>
<h3 id="容器镜像">容器镜像</h3>
<ul>
<li>Docker容器镜像（Images）是一个轻量级的，独立的，可执行的软件包，其中包含运行应用程序所需的一切：代码，运行环境，系统工具，系统库和设置。容器镜像在运行时会成为容器，对于Docker容器，镜像会在Docker Engine上运行时成为容器。不论基础架构如何，容器化软件都可用于基于Linux和Windows的应用程序，始终运行相同。容器将软件与其环境隔离开来，并确保尽管开发和登台之间存在差异，但软件仍可以均匀运行。</li>
</ul>
<h3 id="容器仓库">容器仓库</h3>
<ul>
<li>Docker 的仓库和 git 的仓库比较相似，拥有仓库名、tag。在本地构建完镜像之后，即可通过仓库进行镜像的分发。常用的 Docker hub 有 https://hub.docker.com/ 、 https://cr.console.aliyun.com/ 等。</li>
</ul>
<h2 id="docker特点">Docker特点</h2>
<ul>
<li><strong>标准</strong>： Docker创建了容器的行业标准，因此它们可以在任何地方移植</li>
<li><strong>轻量级</strong>：容器共享计算机的OS系统内核，因此不需要每个应用程序都具有OS，从而提高了服务器效率并降低了服务器和许可成本</li>
<li><strong>安全</strong>：应用程序在容器中更安全，并且Docker提供了业界最强大的默认隔离功能</li>
</ul>
<h2 id="docker与虚拟机">Docker与虚拟机</h2>
<h3 id="虚拟机组织结构">虚拟机组织结构</h3>
<ul>
<li>虚拟机（VM）是将一台服务器转变为多台服务器的物理硬件的抽象。虚拟机管理程序允许多个VM在单台计算机上运行。每个VM包含操作系统，应用程序，必要的二进制文件和库的完整副本-占用数十GB。VM也可能启动缓慢。<br>
<img src="https://saowu.github.io/blog/post-images/1585984071248.png" alt="" loading="lazy"></li>
</ul>
<h3 id="docker组织结构">Docker组织结构</h3>
<ul>
<li>容器是应用程序层的抽象，将代码和依赖项打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享OS内核，每个容器在用户空间中作为隔离的进程运行。容器占用的空间少于VM（容器映像的大小通常为几十MB），可以处理更多的应用程序，并且需要的VM和操作系统更少。<br>
<img src="https://saowu.github.io/blog/post-images/1585984137288.png" alt="" loading="lazy"></li>
</ul>
<h2 id="docker用处">Docker用处</h2>
<ul>
<li><strong>提供一次性的环境</strong>。 比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</li>
<li><strong>提供弹性的云服务</strong>。 因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</li>
<li><strong>组建微服务架构</strong>。 通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bootstrap搭建的蛋糕商店前端模板]]></title>
        <id>https://saowu.github.io/blog/-L4pb1J0a/</id>
        <link href="https://saowu.github.io/blog/-L4pb1J0a/">
        </link>
        <updated>2020-04-03T12:48:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cakeshop">CakeShop</h1>
<blockquote>
<p>使用Bootstrap搭建的蛋糕商店前端模板</p>
</blockquote>
<p>👉<a href="https://github.com/saowu/CakeShop">GitHub</a></p>
<ul>
<li>图片信息来自于<a href="http://www.holiland.com/">好利来</a>,</li>
<li>个别页面参考<a href="https://jd.com/">京东</a>布局</li>
</ul>
<h4 id="功能模块">功能模块</h4>
<pre><code>1.index.html:首页
2.cakes.html:系列详情
4.details.html:产品详情
3.carts.html:购物车
5.orders.html:订单中心
6.order_details.html:订单详情
</code></pre>
<h4 id="ui展示">UI展示</h4>
<p><img src="https://saowu.github.io/blog/post-images/1585918297393.png" alt="" loading="lazy"><br>
<img src="https://saowu.github.io/blog/post-images/1585918305938.png" alt="" loading="lazy"><br>
<img src="https://saowu.github.io/blog/post-images/1585918314818.png" alt="" loading="lazy"><br>
<img src="https://saowu.github.io/blog/post-images/1585918322494.png" alt="" loading="lazy"><br>
<img src="https://saowu.github.io/blog/post-images/1585918331029.png" alt="" loading="lazy"><br>
<img src="https://saowu.github.io/blog/post-images/1585918345314.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《大话设计模式》学习笔记]]></title>
        <id>https://saowu.github.io/blog/V2m1nsMuh/</id>
        <link href="https://saowu.github.io/blog/V2m1nsMuh/">
        </link>
        <updated>2020-04-03T12:33:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="designpatterns">DesignPatterns</h1>
<blockquote>
<p>Java实现的设计模式案例</p>
</blockquote>
<p>👉<a href="https://github.com/saowu/DesignPatterns">GitHub</a></p>
<p>本项目是学习《大话设计模式》一书的学习笔记，欢迎指正(部分来自其他，如侵必删)。</p>
<h2 id="一-设计原则">一、设计原则</h2>
<pre><code>1.单一职责原则（SPR）：就一个类而言，应该仅有一个引起它变化的原因。
    如果一个类的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想
    不到的破坏。软件设计真正要做的内容，就是发现职责并把那些职责相互分离。如果你能够想到多于一个动机去改变一个类，那么这个类就具有多于一个职责。

2.开放-封闭原则（OCP）：是说软件实体（类、模块、函数等）应该可以扩展，但是不可以修改。
    面对需求，对程序的改动是通过增加新代码，而不是更改现有代码。该原则是面向对象的核心。遵循这个原则可以带来巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员
    应该仅对程序中频繁变化的那部分做出抽象，然而，对于应用程序中每个部分都刻意的抽象也不是个好主意。拒绝不成熟抽象和抽象本身同样重要。
    
3.依赖倒转原则（DIP）：抽象不依赖细节，细节应该依赖抽象。
    A.高层模块不应该依赖低层模块。两个都应该依赖抽象。
    B.抽象不应该依赖细节。细节应该依赖抽象。
    依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类
    或者接口，那就是面向对象设计，反之就是过程化设计了。
    
4.里氏代换原则（LSP）:子类型必须能够替换掉它们的父类型。
    一个软件实体如果使用一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，软件里面，把父类替换成它的子类，程序的行为没有变化。
 
5.接口隔离原则(ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。
    根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不
    该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，
    有严格的定义和结构，比如Java语言中的interface。
     
6.迪米特法则(LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。
    迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调
    用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。

7.合成/聚合复用原则(CARP)：尽量使用合成/聚合，尽量不要用类继承。
</code></pre>
<h2 id="二-设计模式">二、设计模式</h2>
<h4 id="1-简单工厂模式-计算器">1. 简单工厂模式-----计算器</h4>
<pre><code>package simple_factory_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Operation</td>
<td>运算类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>OperationAdd</td>
<td>加法类</td>
<td>class</td>
<td>extends Operation</td>
</tr>
<tr>
<td>OperationSub</td>
<td>减法类</td>
<td>class</td>
<td>extends Operation</td>
</tr>
<tr>
<td>OperationMul</td>
<td>乘法类</td>
<td>class</td>
<td>extends Operation</td>
</tr>
<tr>
<td>OperationDiv</td>
<td>除法类</td>
<td>class</td>
<td>extends Operation</td>
</tr>
<tr>
<td>OperationDiv</td>
<td>除法类</td>
<td>class</td>
<td>extends Operation</td>
</tr>
<tr>
<td>OperationFactory</td>
<td>运算工厂类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>SimpleFactoryMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>简单工厂模式：专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。简单工厂模式属于创建型模式又叫做静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。</p>
<h4 id="2-策略模式-商场促销">2. 策略模式-----商场促销</h4>
<pre><code>package strategy_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>BaseCharge</td>
<td>收费算法类</td>
<td>abstract class</td>
<td>---</td>
</tr>
<tr>
<td>DiscountCharge</td>
<td>打折收费类</td>
<td>class</td>
<td>extends BaseCharge</td>
</tr>
<tr>
<td>NormalCharge</td>
<td>正常收费（无折扣）</td>
<td>class</td>
<td>extends BaseCharge</td>
</tr>
<tr>
<td>ReturnCharge</td>
<td>返利收费</td>
<td>class</td>
<td>extends BaseCharge</td>
</tr>
<tr>
<td>TypeEnum</td>
<td>收费折扣类型</td>
<td>enum</td>
<td>---</td>
</tr>
<tr>
<td>ChargeContext</td>
<td>策略算法上下文引用</td>
<td>class</td>
<td>----</td>
</tr>
<tr>
<td>StrategyMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>策略模式：它定义了算法家族，分别分装起来，让他们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。</p>
<h4 id="3装饰模式-穿衣系统">3.装饰模式-----穿衣系统</h4>
<pre><code>package decorator_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Component</td>
<td>公共抽象类</td>
<td>abstract class</td>
<td>---</td>
</tr>
<tr>
<td>Decorator</td>
<td>装饰类</td>
<td>class</td>
<td>extends Component</td>
</tr>
<tr>
<td>Persion</td>
<td>人物类</td>
<td>class</td>
<td>extends Component</td>
</tr>
<tr>
<td>BigTrouser</td>
<td>工裤类</td>
<td>class</td>
<td>extends Decorator</td>
</tr>
<tr>
<td>Sneaker</td>
<td>鞋子类</td>
<td>class</td>
<td>extends Decorator</td>
</tr>
<tr>
<td>TShirts</td>
<td>T恤类</td>
<td>class</td>
<td>extends Decorator</td>
</tr>
<tr>
<td>DecoratorMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>装饰模式：动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。</p>
<h4 id="4代理模式-送礼物">4.代理模式-----送礼物</h4>
<pre><code>package proxy_mode
</code></pre>
<p>代理模式：为其他对象提供一种代理以控制对这个对象的访问。</p>
<h5 id="a静态代理方式">a.静态代理方式</h5>
<pre><code>package proxy_mode.static_proxy_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>IGiveGift</td>
<td>送礼物接口</td>
<td>interface</td>
<td>---</td>
</tr>
<tr>
<td>Suitors</td>
<td>追求者</td>
<td>class</td>
<td>implements IGiveGift</td>
</tr>
<tr>
<td>Proxy</td>
<td>代理类</td>
<td>class</td>
<td>implements IGiveGift</td>
</tr>
<tr>
<td>StaticProxyMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<h5 id="bjdk动态代理方式">b.jdk动态代理方式</h5>
<pre><code>package proxy_mode.dynamic_proxy_mode.jdk_dynamic_proxy
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>IGiveGift</td>
<td>送礼物接口</td>
<td>interface</td>
<td>---</td>
</tr>
<tr>
<td>Suitors</td>
<td>追求者</td>
<td>class</td>
<td>implements IGiveGift</td>
</tr>
<tr>
<td>JdkProxy</td>
<td>代理类</td>
<td>class</td>
<td>implements InvocationHandler</td>
</tr>
<tr>
<td>JdkDynamicProxy</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<h5 id="ccglib动态代理方式">c.cglib动态代理方式</h5>
<pre><code>package proxy_mode.dynamic_proxy_mode.cglib_dynamic_proxy
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Suitors</td>
<td>追求者</td>
<td>class</td>
<td>implements IGiveGift</td>
</tr>
<tr>
<td>CglibProxy</td>
<td>代理类</td>
<td>class</td>
<td>implements MethodInterceptor</td>
</tr>
<tr>
<td>CglibDynamicProxy</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>需要导入<a href="https://mvnrepository.com/artifact/cglib/cglib/3.2.8">cglib-2.2.8.jar</a></p>
<h4 id="5-工厂模式-计算器">5. 工厂模式-----计算器</h4>
<pre><code>package factory_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Operation</td>
<td>运算类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>OperationAdd</td>
<td>加法类</td>
<td>class</td>
<td>extends Operation</td>
</tr>
<tr>
<td>OperationSub</td>
<td>减法类</td>
<td>class</td>
<td>extends Operation</td>
</tr>
<tr>
<td>OperationMul</td>
<td>乘法类</td>
<td>class</td>
<td>extends Operation</td>
</tr>
<tr>
<td>OperationDiv</td>
<td>除法类</td>
<td>class</td>
<td>extends Operation</td>
</tr>
<tr>
<td>IFactory</td>
<td>运算工厂接口</td>
<td>interface</td>
<td>---</td>
</tr>
<tr>
<td>AddFactory</td>
<td>加法工厂类</td>
<td>class</td>
<td>implements IFactory</td>
</tr>
<tr>
<td>SubFactory</td>
<td>减法工厂类</td>
<td>class</td>
<td>implements IFactory</td>
</tr>
<tr>
<td>MulFactory</td>
<td>乘法工厂类</td>
<td>class</td>
<td>implements IFactory</td>
</tr>
<tr>
<td>DivFactory</td>
<td>除法工厂类</td>
<td>class</td>
<td>implements IFactory</td>
</tr>
<tr>
<td>FactoryMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。</p>
<p>相比简单工厂模式，工厂模式遵循开放-封闭原则，但增加了开发量。</p>
<h4 id="6-原型模式-印简历">6. 原型模式-----印简历</h4>
<h5 id="a浅拷贝">a.浅拷贝</h5>
<pre><code>package prototype_mode.shallow_copy_model
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Resume</td>
<td>简历类</td>
<td>class</td>
<td>implements Cloneable</td>
</tr>
<tr>
<td>Address</td>
<td>地址类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>PrototypeMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<h5 id="b深拷贝-1">b.深拷贝-1</h5>
<pre><code>package prototype_mode.deep_copy_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Resume_1</td>
<td>简历类</td>
<td>class</td>
<td>implements Cloneable</td>
</tr>
<tr>
<td>Address_1</td>
<td>地址类</td>
<td>class</td>
<td>implements Cloneable</td>
</tr>
<tr>
<td>PrototypeMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<h5 id="c深拷贝-2">c.深拷贝-2</h5>
<pre><code>package prototype_mode.deep_copy_mode2
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Resume_2</td>
<td>简历类</td>
<td>class</td>
<td>implements Cloneable</td>
</tr>
<tr>
<td>Address_2</td>
<td>地址类</td>
<td>class</td>
<td>implements Serializable</td>
</tr>
<tr>
<td>PrototypeMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>浅拷贝</strong>：对值类型的成员变量进行值的复制,对引用类型的成员变量仅仅复制引用,不复制引用的对象。</li>
<li><strong>深拷贝</strong>：对值类型的成员变量进行值的复制,对引用类型的成员变量也进行引用对象的复制。</li>
</ul>
<p>原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<h4 id="7-模板方法模式-抄试题">7. 模板方法模式-----抄试题</h4>
<pre><code>package template_method_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>BaseTestPaper</td>
<td>黑板试卷类</td>
<td>abstract class</td>
<td>---</td>
</tr>
<tr>
<td>TestPaperA</td>
<td>手抄试卷A类</td>
<td>class</td>
<td>extends BaseTestPaper</td>
</tr>
<tr>
<td>TestPaperA</td>
<td>手抄试卷B类</td>
<td>class</td>
<td>extends BaseTestPaper</td>
</tr>
<tr>
<td>TemplateMethodMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>模板方法模式：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>模板方法模式实现了很好的代码复用性。</p>
<h4 id="8-外观模式-炒股票">8. 外观模式-----炒股票</h4>
<pre><code>package facade_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stock</td>
<td>股票类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Realty</td>
<td>房地产类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>NationalDebt</td>
<td>国债类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Fund</td>
<td>基金类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>FacadeMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>外观模式：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p>完美体现了依赖倒转原则和迪米特法则的思想。</p>
<h4 id="9-建造者模式-产品生产线">9. 建造者模式-----产品生产线</h4>
<pre><code>package builder_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>BaseBuilder</td>
<td>建造者抽象类</td>
<td>abstract class</td>
<td>---</td>
</tr>
<tr>
<td>ConcreteBuilder1</td>
<td>具体建造者类1</td>
<td>class</td>
<td>extends BaseBuilder</td>
</tr>
<tr>
<td>ConcreteBuilder2</td>
<td>具体建造者类2</td>
<td>class</td>
<td>extends BaseBuilder</td>
</tr>
<tr>
<td>Product</td>
<td>产品类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Director</td>
<td>指挥者类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>BuilderMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<h4 id="10-观察者模式-员工偷懒">10. 观察者模式-----员工偷懒</h4>
<pre><code>package observer_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>BaseObserver</td>
<td>抽象观察者</td>
<td>abstract class</td>
<td>---</td>
</tr>
<tr>
<td>BaseSubject</td>
<td>抽象通知者</td>
<td>abstract class</td>
<td>---</td>
</tr>
<tr>
<td>Boss</td>
<td>老板类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Employee</td>
<td>员工类</td>
<td>class</td>
<td>extends BaseObserver</td>
</tr>
<tr>
<td>Reception</td>
<td>前台类</td>
<td>class</td>
<td>extends BaseSubject</td>
</tr>
<tr>
<td>ObserverMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>观察者模式：该模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p>
<h4 id="11-抽象工厂模式反射-切换db源">11. 抽象工厂模式+反射-----切换DB源</h4>
<pre><code>package abstract_factory_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>IUser</td>
<td>操作用户接口</td>
<td>interface</td>
<td>---</td>
</tr>
<tr>
<td>IDepartment</td>
<td>操作部门接口</td>
<td>interface</td>
<td>---</td>
</tr>
<tr>
<td>User</td>
<td>用户实体</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Department</td>
<td>部门实体</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>MySqlUser</td>
<td>mysql数据源-User</td>
<td>class</td>
<td>implements IUser</td>
</tr>
<tr>
<td>MySqlDepartment</td>
<td>mysql数据源-Department</td>
<td>class</td>
<td>implements IUser</td>
</tr>
<tr>
<td>SqlServerUser</td>
<td>sqlserver数据源-User</td>
<td>class</td>
<td>implements IDepartment</td>
</tr>
<tr>
<td>SqlServerDepartment</td>
<td>sqlserver数据源-Department</td>
<td>class</td>
<td>implements IDepartment</td>
</tr>
<tr>
<td>DBEnum</td>
<td>反射-全限定名</td>
<td>enum</td>
<td>---</td>
</tr>
<tr>
<td>DataSourceFactory</td>
<td>数据源切换工厂</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>AbstractFactoryMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>注意:<a href="https://blog.csdn.net/jerry11112/article/details/80618420">简单工厂、抽象工厂和抽象工厂模式的区别</a>。</p>
<h4 id="12-状态模式-工作状态">12. 状态模式-----工作状态</h4>
<pre><code>package state_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>State</td>
<td>状态抽象类</td>
<td>abstract</td>
<td>---</td>
</tr>
<tr>
<td>Work</td>
<td>工作类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>ForenoonStare</td>
<td>上午工作状态类</td>
<td>class</td>
<td>extends State</td>
</tr>
<tr>
<td>NoonState</td>
<td>中午工作状态类</td>
<td>class</td>
<td>extends State</td>
</tr>
<tr>
<td>AfternoonState</td>
<td>下午工作状态类</td>
<td>class</td>
<td>extends State</td>
</tr>
<tr>
<td>EveningState</td>
<td>晚间工作状态</td>
<td>class</td>
<td>extends State</td>
</tr>
<tr>
<td>SleepingState</td>
<td>睡眠状态类</td>
<td>class</td>
<td>extends State</td>
</tr>
<tr>
<td>RestState</td>
<td>下班休息状态类</td>
<td>class</td>
<td>extends State</td>
</tr>
<tr>
<td>StateMode</td>
<td>状态模式启动类</td>
<td>class</td>
<td>extends State</td>
</tr>
</tbody>
</table>
<p>状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p>
<h4 id="13-适配器模式">13. 适配器模式</h4>
<pre><code>package adapter_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Target</td>
<td>客户期待的接口</td>
<td>interface</td>
<td>---</td>
</tr>
<tr>
<td>Adaptee</td>
<td>需要适配的类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Adapter</td>
<td>适配器类</td>
<td>class</td>
<td>implements Target</td>
</tr>
<tr>
<td>AdapterMain</td>
<td>适配器启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>适配器模式：将一个类的接口转换成客户希望的另一个接口。该模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<h4 id="14-备忘录模式">14. 备忘录模式</h4>
<pre><code>package memento_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Originator</td>
<td>发起人类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Memento</td>
<td>备忘录类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Caretaker</td>
<td>管理者类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>MementoMode</td>
<td>备忘录模式启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态。这样以后就可以将该对象恢复到原先保存的状态。</p>
<h4 id="15-组合模式">15. 组合模式</h4>
<pre><code>package composite_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Component</td>
<td>对象默认接口</td>
<td>abstract</td>
<td>---</td>
</tr>
<tr>
<td>Composite</td>
<td>枝结点</td>
<td>class</td>
<td>extends Component</td>
</tr>
<tr>
<td>Leaf</td>
<td>叶子结点</td>
<td>class</td>
<td>extends Component</td>
</tr>
<tr>
<td>CompositeMode</td>
<td>组合模式启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>组合模式：将对象组成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<h4 id="16-迭代器模式">16. 迭代器模式</h4>
<pre><code>package iterator_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Iterator</td>
<td>迭代器抽象类</td>
<td>abstract</td>
<td>---</td>
</tr>
<tr>
<td>Aggregate</td>
<td>聚集抽象类</td>
<td>abstract</td>
<td>---</td>
</tr>
<tr>
<td>ConcreteIterator</td>
<td>正序迭代器类</td>
<td>class</td>
<td>extends Iterator</td>
</tr>
<tr>
<td>ConcreteIteratorDesc</td>
<td>逆序迭代器类</td>
<td>class</td>
<td>extends Iterator</td>
</tr>
<tr>
<td>ConcreteAggregate</td>
<td>具体聚集类</td>
<td>class</td>
<td>extends Aggregate</td>
</tr>
<tr>
<td>IteratorMode</td>
<td>迭代器模式启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。</p>
<h4 id="17-单例模式">17. 单例模式</h4>
<pre><code>package singleton_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Singleton1</td>
<td>懒汉式（线程不安全）</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Singleton2</td>
<td>懒汉式（线程安全，同步方法，不推荐使用）</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Singleton3</td>
<td>饿汉式（线程安全）</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Singleton4</td>
<td>静态内部类加载（线程安全）</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Singleton5</td>
<td>枚举（线程安全）</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Singleton6</td>
<td>懒汉式双重校验锁法（通常线程安全，不可保证完全安全）</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Singleton7</td>
<td>懒汉式双重检查终极版（面试手写推荐）</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Singleton8</td>
<td>使用 ThreadLocal 实现（线程安全）</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Singleton9</td>
<td>使用CAS 锁实现（线程安全）</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<pre><code>特点:
    1.一个类只允许产生一个实例化对象。
    2.单例类构造方法私有化，不允许外部创建对象。
    3.单例类向外提供静态方法，调用方法返回内部创建的实例化对象。
</code></pre>
<p><a href="https://mp.weixin.qq.com/s/-MShVr8txQ6nced-EhxAIg">资料来源</a></p>
<h4 id="18-桥接模式">18. 桥接模式</h4>
<pre><code>package bridge_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implementor</td>
<td>实现</td>
<td>abstract</td>
<td>---</td>
</tr>
<tr>
<td>ConcreteImplementorA</td>
<td>具体实现A</td>
<td>class</td>
<td>extends Implementor</td>
</tr>
<tr>
<td>ConcreteImplementorB</td>
<td>具体实现B</td>
<td>class</td>
<td>extends Implementor</td>
</tr>
<tr>
<td>Abstraction</td>
<td>抽象</td>
<td>abstract</td>
<td>---</td>
</tr>
<tr>
<td>RefinedAbstraction</td>
<td>被提炼的抽象</td>
<td>class</td>
<td>extends Abstraction</td>
</tr>
<tr>
<td>BridgeMode</td>
<td>桥接模式启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立的变化。</p>
<h4 id="19-命令模式">19. 命令模式</h4>
<pre><code>package command_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command</td>
<td>命令接口</td>
<td>abstract</td>
<td>---</td>
</tr>
<tr>
<td>ConcreteCommand</td>
<td>命令实现类</td>
<td>class</td>
<td>extends Command</td>
</tr>
<tr>
<td>Receiver</td>
<td>请求者</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Invoker</td>
<td>要求执行者</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>CommandMode</td>
<td>命令模式启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>命令模式：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[简单问卷调查系统]]></title>
        <id>https://saowu.github.io/blog/ugWz7JSYQ/</id>
        <link href="https://saowu.github.io/blog/ugWz7JSYQ/">
        </link>
        <updated>2020-04-03T12:20:46.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="votingsystem">VotingSystem</h1>
<blockquote>
<p>Bootstrap+Django+sqlite3 编写的简单问卷调查系统</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h1 id="votingsystem">VotingSystem</h1>
<blockquote>
<p>Bootstrap+Django+sqlite3 编写的简单问卷调查系统</p>
</blockquote>
<!-- more -->
<p>👉<a href="https://github.com/saowu/VotingSystem">GitHub</a></p>
<h4 id="版本配置">版本配置</h4>
<pre><code>Package    Version
---------- -------
asgiref    3.2.3  
Django     3.0.3  
pip        19.0.3 
pytz       2019.3 
setuptools 40.8.0 
sqlparse   0.3.0 
</code></pre>
<h4 id="默认管理账户">默认管理账户</h4>
<ul>
<li><code>admin</code>:saowu</li>
<li><code>password</code>:admin12345</li>
</ul>
<h4 id="ui展示">UI展示</h4>
<p><img src="https://saowu.github.io/blog/post-images/1585916720977.png" alt="" loading="lazy"><br>
<img src="https://saowu.github.io/blog/post-images/1585916727536.png" alt="" loading="lazy"><br>
<img src="https://saowu.github.io/blog/post-images/1585916736036.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 贪吃蛇]]></title>
        <id>https://saowu.github.io/blog/ExvMF31VX/</id>
        <link href="https://saowu.github.io/blog/ExvMF31VX/">
        </link>
        <updated>2020-04-03T12:15:15.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>java编写的贪吃蛇（火影风）</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>java编写的贪吃蛇（火影风）</p>
</blockquote>
<!-- more -->
<p>👉<a href="https://github.com/saowu/SnakeGame">Github</a></p>
<h4 id="版本配置">版本配置</h4>
<ul>
<li>jdk8+</li>
<li>mysql 5.7</li>
</ul>
<h4 id="ui展示">UI展示</h4>
<p><img src="https://saowu.github.io/blog/post-images/1585916237725.png" alt="" loading="lazy"><br>
<img src="https://saowu.github.io/blog/post-images/1585916245690.png" alt="" loading="lazy"><br>
<img src="https://saowu.github.io/blog/post-images/1585916251778.png" alt="" loading="lazy"><br>
<img src="https://saowu.github.io/blog/post-images/1585916260139.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ FigureBed图床系统]]></title>
        <id>https://saowu.github.io/blog/IVwOk1Phb/</id>
        <link href="https://saowu.github.io/blog/IVwOk1Phb/">
        </link>
        <updated>2020-04-03T12:06:39.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Flask 个人图床</p>
</blockquote>
<p>👉<a href="http://118.89.237.69:8000">demo website</a><br>
👉<a href="https://github.com/saowu/FigureBed">GitHub</a></p>
<h4 id="功能支持">功能支持</h4>
<pre><code>1.支持多文件上传（set max=5）
2.支持导出上传记录（csv文件）
3.支持返回多种链接格式 （link, markdown, html, bbcode，removal）
4.可以通过removal链接自行删除图片文件
5.使用mysql数据库
6.支持拖动上传
</code></pre>
<h4 id="docker部署">Docker部署</h4>
<pre><code>#构建flask+gunicorn+gevent(+nginx)
$docker build -t saowu/figurebed:1.0 .
$docker run  -p 8000:8888 -v /home/myDataVolume:/home/myDataVolume -d saowu/figurebed:1.0

#构建nginx(cd /nginx)
$docker build -t saowu/nginx:1.0 .
$docker run --name nginx1 -p 80:80 -d saowu/nginx:1.0
</code></pre>
<h4 id="ui展示">UI展示</h4>
<p><img src="https://saowu.github.io/blog/post-images/1585915830120.png" alt="" loading="lazy"><br>
<img src="https://saowu.github.io/blog/post-images/1585915839679.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言程序集（76-80）]]></title>
        <id>https://saowu.github.io/blog/c-yu-yan-cheng-xu-ji-76-80/</id>
        <link href="https://saowu.github.io/blog/c-yu-yan-cheng-xu-ji-76-80/">
        </link>
        <updated>2020-04-03T06:10:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="76整数数值交换">76.整数数值交换</h3>
<pre><code>#include&lt;stdio.h&gt;
int main()
{   int a=1,b=2;
    a-=b;
    b+=a;
    a=b-a;
    printf(&quot;a=%d,b=%d&quot;,a,b);
    return 0;
}
</code></pre>
<h3 id="77将9个学生的考试成绩进行分段统计">77.将9个学生的考试成绩进行分段统计...</h3>
<pre><code>将9个学生的考试成绩进行分段统计，考试成绩放在a数组中，各分数段的人数存在b组中：成绩为60到69的人数
存到b［0］中，成绩为70到79的人数存到b［1］，成绩为80到89的人数存到b［2］，成绩为90到99的人数存到b［3
］，成绩为100的人数存到b［4］，成绩为60以下的人数存到b［5］中。请输出数组b中的数据。假设a数组中的整数
数据为：93 85 77 68 59 43 94 75 98。 要求程序简练，采用的分支语录中分支语句中支数尽量少。

#include&lt;stdio.h&gt;
int main()
{   int a[9]= {93,85,77,68,59,43,94,75,98},b[6]= {0},i;
    for(i=0; i&lt;9; i++)
        if(a[i]&lt;60)
            b[5]++;
        else
            b[(a[i]-60)/10]++;
    for(i=0; i&lt;6; i++)
        printf(&quot;%d&quot;,b[i]);
    return 0;
}
</code></pre>
<h3 id="78利用指针设计一个函数求字符串长度">78.利用指针设计一个函数，求字符串长度</h3>
<pre><code>int strlen(char *s) {
    char *p=s;
    while(*p)
        p++;
    return p-s;
}
</code></pre>
<h3 id="79不规则数组去重">79.不规则数组去重</h3>
<pre><code>(自己写的)
#include&lt;stdio.h&gt;
int main()
{   int a[]= {1,2,2,2,4,5,5,8,9,9};
    int i,j,n=10,z,m;
    for(i=0; i&lt;n; i++) {
        //更新数组长度，m必须每次全部平移后才能更新
        m=n;
        for(j=i+1,z=i+1; j&lt;m; j++)
            if(a[i]!=a[j]) {
                a[z++]=a[j];
            } else {
                //记录数组移除重复数量
                n--;
            }
    }

    for(int k=0; k&lt;n; k++)
        printf(&quot;%d&quot;,a[k]);
    return 0;
}

(老师写的)
#include&lt;stdio.h&gt;
int main()
{   int a[]= {1,2,2,2,2,4,5,5,8,9,9};
    int i,j,k,n=11;
    for(i=0; i&lt;n; i++) {
        for(j=i+1; j&lt;n;)
            if(a[i]==a[j]) {
                for(k=j+1; k&lt;n; k++)
                    a[k-1]=a[k];
                n--;
            } else {
                j++;
            }
    }

    for(int t=0; t&lt;n; t++)
        printf(&quot;%d&quot;,a[t]);
    return 0;
}
</code></pre>
<h3 id="80统计单词个数并记录最长单词长度p166">80.统计单词个数，并记录最长单词长度(p166)</h3>
<pre><code>#include&lt;stdio.h&gt;

int main()
{
    char string[81];
    int i,num=0,len=0,max=0;
    char c;
    gets(string);
    for(i=0; (c=string[i])!='\0'; i++)
        if(c==' ') {
            if(len&gt;max)
                max=len;
            len=0;
        }
        else if(len==0) {
            len++;
            num++;
        }
        else {
            len++;
        }

    printf(&quot;There are %d words ,The longest word is %d&quot;,num,max);
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>