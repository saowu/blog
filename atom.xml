<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://saowu.github.io/blog/</id>
    <title>saowu&apos;s Blog</title>
    <updated>2020-04-06T02:56:08.716Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://saowu.github.io/blog/"/>
    <link rel="self" href="https://saowu.github.io/blog/atom.xml"/>
    <subtitle>A programmer who wants to be happy and muddle along</subtitle>
    <logo>https://saowu.github.io/blog/images/avatar.png</logo>
    <icon>https://saowu.github.io/blog/favicon.ico</icon>
    <rights>All rights reserved 2020, saowu&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[让Google搜索到GitHub Pages]]></title>
        <id>https://saowu.github.io/blog/4tCVcic30/</id>
        <link href="https://saowu.github.io/blog/4tCVcic30/">
        </link>
        <updated>2020-04-04T12:55:35.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>免费的东西自然是越香越好啊</p>
</blockquote>
<h2 id="一-查看是否被收录">一、查看是否被收录</h2>
<ul>
<li>首先查看你的博客地址是否已经被Google收录，在Google的搜索栏中搜索：<code>site:https://xxxx.github.io</code>，其中https://xxxx.github.io为你的博客地址，如果结果是尝试使用Google Search Console，则意味着没有被收录。</li>
</ul>
<p><em>如果搜索出你想要的结果，那么不用继续往下看了。</em></p>
<h2 id="二-搜索资源提交">二、搜索资源提交</h2>
<ul>
<li>
<p>进入Google Web Master，点击： <a href="https://search.google.com/search-console?hl=zh-CN&amp;utm_source=wmx&amp;utm_medium=deprecation-pane&amp;utm_content=home&amp;resource_id=https://saowu.github.io/">Google Search Console</a>（若未登录谷歌账号，需要先登录谷歌账号）</p>
</li>
<li>
<p>点击<code>网址前缀</code>添加（网域方式验证方式单一），提交你的博客网址，然后跳转到如下界面进行验证。<br>
<img src="https://saowu.github.io/blog//post-images/1586005315008.png" alt="" loading="lazy"></p>
</li>
<li>
<p>验证方式有一下几种，根据实际情况，按要求验证即可。</p>
<ul>
<li>将 HTML 文件上传至您的网站<br>
<img src="https://saowu.github.io/blog//post-images/1586005851160.png" alt="" loading="lazy"></li>
<li>向您网站的首页添加元标记<br>
<img src="https://saowu.github.io/blog//post-images/1586006930652.png" alt="" loading="lazy"></li>
<li>使用您的 Google 跟踪代码管理器帐号<br>
<img src="https://saowu.github.io/blog//post-images/1586005886077.png" alt="" loading="lazy"></li>
<li>将 DNS 记录与 Google 关联<br>
<img src="https://saowu.github.io/blog//post-images/1586005899681.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h2 id="三-添加站点地图">三、添加站点地图</h2>
<p>站点地图(Site Map)是用来注明网站结构的文件，我们希望搜索引擎的爬虫了解我们的网站结构,以便于高效爬取内容，快速建立索引。</p>
<ul>
<li>点击进入 <a href="https://www.xml-sitemaps.com/">XML-Sitemaps.com</a> 页面，输入博客地址，点击 start。<br>
<img src="https://saowu.github.io/blog//post-images/1586006006506.png" alt="" loading="lazy"></li>
<li>等待搜索完成，点击 VIEW SITEMAP DETAILS。<br>
<img src="https://saowu.github.io/blog//post-images/1586006110505.png" alt="" loading="lazy"></li>
<li>下载 SITEMAP 文件sitemap.xml并将其上传到网站的根目录。<br>
<img src="https://saowu.github.io/blog//post-images/1586006133718.png" alt="" loading="lazy"></li>
<li>在 Google Search console 中添加你的 sitemap URL。
<ul>
<li>还是刚刚的Google Search Console网站，点击刚刚验证成功的你的网站进入控制台，在左边侧边栏“抓取”下找到“站点地图”,将https://xxxx.github.io/sitemap.xml提交并刷新，就可以看到博客的网站结构了。<br>
<img src="https://saowu.github.io/blog//post-images/1586006241464.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
<h2 id="四-手动提交google抓取可选">四、手动提交Google抓取（可选）</h2>
<ul>
<li>等待Google抓取所需时间比较长，可以利用Google网页检查工具手动提交网址。（不是必须，等待Gooogle自行抓取也是可以的）<br>
<img src="https://saowu.github.io/blog//post-images/1586006394550.png" alt="" loading="lazy"></li>
<li>等待片刻后，网页检查结果就会出来了，接下来点击请求编入索引即可。<br>
<img src="https://saowu.github.io/blog//post-images/1586006475987.png" alt="" loading="lazy"></li>
</ul>
<h2 id="五-google收录成功">五、Google收录成功</h2>
<figure data-type="image" tabindex="1"><img src="https://saowu.github.io/blog//post-images/1586006635125.png" alt="" loading="lazy"></figure>
<p>更新自<a href="https://evanli.github.io/blog/2018/10/25/let-jekyll-github-pages-be-searched-by-google/">EvanLi的博客</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker安装MySQL]]></title>
        <id>https://saowu.github.io/blog/xjJ08KIvI/</id>
        <link href="https://saowu.github.io/blog/xjJ08KIvI/">
        </link>
        <updated>2020-04-04T08:04:10.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>操作容器的快乐，一般人都能体会到，没错你就是一般人。</p>
</blockquote>
<h2 id="一-检索mysql容器">一、检索mysql容器</h2>
<pre><code>docker search mysql
</code></pre>
<h2 id="二-拉取msql容器镜像">二、拉取Msql容器镜像</h2>
<pre><code>docker pull mysql:latest
</code></pre>
<h2 id="三-查看全部容器镜像">三、查看全部容器镜像</h2>
<pre><code>docker images
</code></pre>
<h2 id="四-运行镜像生成容器">四、运行镜像生成容器</h2>
<ul>
<li>-p &lt;宿主机port：容器port&gt;</li>
<li>-d &lt;镜像名：版本&gt;</li>
<li>--name &lt;容器别名&gt;</li>
</ul>
<pre><code>docker run --name mysql1 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest
</code></pre>
<h2 id="五-查看全部容器">五、查看全部容器</h2>
<pre><code>docker ps -a
</code></pre>
<h2 id="六-进入容器">六、进入容器</h2>
<ul>
<li>-i :即使没有附加也保持STDIN 打开</li>
<li>-t :分配一个伪终端 <code>/bin/bash</code></li>
</ul>
<pre><code>docker exec -i -t mysql1 /bin/bash
</code></pre>
<h2 id="七-登陆mysql">七、登陆mysql</h2>
<pre><code>mysql -u root -p
</code></pre>
<h2 id="八-修改为root-可以通过任何客户端连接">八、修改为root 可以通过任何客户端连接</h2>
<pre><code>use mysql
ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '123456';
</code></pre>
<h2 id="九-修改数据库中文乱码">九、修改数据库中文乱码</h2>
<pre><code>show variables like 'character%';
</code></pre>
<h2 id="十-远程链接success">十、远程链接Success!</h2>
<figure data-type="image" tabindex="1"><img src="https://saowu.github.io/blog//post-images/1585989623761.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[What is docker ？]]></title>
        <id>https://saowu.github.io/blog/yadpkA34H/</id>
        <link href="https://saowu.github.io/blog/yadpkA34H/">
        </link>
        <updated>2020-04-04T06:57:19.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>据“咳咳咳”学统计，学会了Docker你可以少死去好几百万只手也数不过来的脑细胞。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://saowu.github.io/blog//post-images/1585984531665.png" alt="" loading="lazy"></figure>
<h2 id="docker是什么">Docker是什么？</h2>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以以统一的方式打包他们的应用以及依赖包到一个可移植的<code>容器</code>中，然后发布到任何安装了docker引擎的服务器上（包括流行的Linux机器、windows机器），也可以实现虚拟化。</li>
</ul>
<h2 id="docker-核心概念">Docker 核心概念</h2>
<ul>
<li>Docker 中有三个核心概念：<code>Image</code>、<code>Container</code>、<code>Repository</code>。</li>
</ul>
<h3 id="容器">容器</h3>
<ul>
<li>容器（Container）是打包代码及其所有依赖项的标准软件单元，因此应用程序可以从一个计算环境快速可靠地运行到另一个计算环境。容器的存在离不开镜像的支持，他是镜像运行时的一个载体（类似于实例和类的关系）。依托 Docker 的虚拟化技术，给容器创建了独立的端口、进程、文件等“空间”，Container 就是一个与宿机隔离 “容器”。容器可宿主机之间可以进行 port、volumes、network 等的通信。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低</li>
</ul>
<h3 id="容器镜像">容器镜像</h3>
<ul>
<li>Docker容器镜像（Images）是一个轻量级的，独立的，可执行的软件包，其中包含运行应用程序所需的一切：代码，运行环境，系统工具，系统库和设置。容器镜像在运行时会成为容器，对于Docker容器，镜像会在Docker Engine上运行时成为容器。不论基础架构如何，容器化软件都可用于基于Linux和Windows的应用程序，始终运行相同。容器将软件与其环境隔离开来，并确保尽管开发和登台之间存在差异，但软件仍可以均匀运行。</li>
</ul>
<h3 id="容器仓库">容器仓库</h3>
<ul>
<li>Docker 的仓库和 git 的仓库比较相似，拥有仓库名、tag。在本地构建完镜像之后，即可通过仓库进行镜像的分发。常用的 Docker hub 有 https://hub.docker.com/ 、 https://cr.console.aliyun.com/ 等。</li>
</ul>
<h2 id="docker特点">Docker特点</h2>
<ul>
<li><strong>标准</strong>： Docker创建了容器的行业标准，因此它们可以在任何地方移植</li>
<li><strong>轻量级</strong>：容器共享计算机的OS系统内核，因此不需要每个应用程序都具有OS，从而提高了服务器效率并降低了服务器和许可成本</li>
<li><strong>安全</strong>：应用程序在容器中更安全，并且Docker提供了业界最强大的默认隔离功能</li>
</ul>
<h2 id="docker与虚拟机">Docker与虚拟机</h2>
<h3 id="虚拟机组织结构">虚拟机组织结构</h3>
<ul>
<li>虚拟机（VM）是将一台服务器转变为多台服务器的物理硬件的抽象。虚拟机管理程序允许多个VM在单台计算机上运行。每个VM包含操作系统，应用程序，必要的二进制文件和库的完整副本-占用数十GB。VM也可能启动缓慢。<br>
<img src="https://saowu.github.io/blog//post-images/1585984071248.png" alt="" loading="lazy"></li>
</ul>
<h3 id="docker组织结构">Docker组织结构</h3>
<ul>
<li>容器是应用程序层的抽象，将代码和依赖项打包在一起。多个容器可以在同一台机器上运行，并与其他容器共享OS内核，每个容器在用户空间中作为隔离的进程运行。容器占用的空间少于VM（容器映像的大小通常为几十MB），可以处理更多的应用程序，并且需要的VM和操作系统更少。<br>
<img src="https://saowu.github.io/blog//post-images/1585984137288.png" alt="" loading="lazy"></li>
</ul>
<h2 id="docker用处">Docker用处</h2>
<ul>
<li><strong>提供一次性的环境</strong>。 比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</li>
<li><strong>提供弹性的云服务</strong>。 因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</li>
<li><strong>组建微服务架构</strong>。 通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《大话设计模式》学习笔记]]></title>
        <id>https://saowu.github.io/blog/V2m1nsMuh/</id>
        <link href="https://saowu.github.io/blog/V2m1nsMuh/">
        </link>
        <updated>2020-04-03T12:33:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="designpatterns">DesignPatterns</h1>
<blockquote>
<p>Java实现的设计模式案例</p>
</blockquote>
<p>👉<a href="https://github.com/saowu/DesignPatterns">GitHub</a></p>
<p>本项目是学习《大话设计模式》一书的学习笔记，欢迎指正(部分来自其他，如侵必删)。</p>
<h2 id="一-设计原则">一、设计原则</h2>
<pre><code>1.单一职责原则（SPR）：就一个类而言，应该仅有一个引起它变化的原因。
    如果一个类的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想
    不到的破坏。软件设计真正要做的内容，就是发现职责并把那些职责相互分离。如果你能够想到多于一个动机去改变一个类，那么这个类就具有多于一个职责。

2.开放-封闭原则（OCP）：是说软件实体（类、模块、函数等）应该可以扩展，但是不可以修改。
    面对需求，对程序的改动是通过增加新代码，而不是更改现有代码。该原则是面向对象的核心。遵循这个原则可以带来巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员
    应该仅对程序中频繁变化的那部分做出抽象，然而，对于应用程序中每个部分都刻意的抽象也不是个好主意。拒绝不成熟抽象和抽象本身同样重要。
    
3.依赖倒转原则（DIP）：抽象不依赖细节，细节应该依赖抽象。
    A.高层模块不应该依赖低层模块。两个都应该依赖抽象。
    B.抽象不应该依赖细节。细节应该依赖抽象。
    依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类
    或者接口，那就是面向对象设计，反之就是过程化设计了。
    
4.里氏代换原则（LSP）:子类型必须能够替换掉它们的父类型。
    一个软件实体如果使用一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，软件里面，把父类替换成它的子类，程序的行为没有变化。
 
5.接口隔离原则(ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。
    根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不
    该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，
    有严格的定义和结构，比如Java语言中的interface。
     
6.迪米特法则(LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。
    迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调
    用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。

7.合成/聚合复用原则(CARP)：尽量使用合成/聚合，尽量不要用类继承。
</code></pre>
<h2 id="二-设计模式">二、设计模式</h2>
<h4 id="1-简单工厂模式-计算器">1. 简单工厂模式-----计算器</h4>
<pre><code>package simple_factory_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Operation</td>
<td>运算类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>OperationAdd</td>
<td>加法类</td>
<td>class</td>
<td>extends Operation</td>
</tr>
<tr>
<td>OperationSub</td>
<td>减法类</td>
<td>class</td>
<td>extends Operation</td>
</tr>
<tr>
<td>OperationMul</td>
<td>乘法类</td>
<td>class</td>
<td>extends Operation</td>
</tr>
<tr>
<td>OperationDiv</td>
<td>除法类</td>
<td>class</td>
<td>extends Operation</td>
</tr>
<tr>
<td>OperationDiv</td>
<td>除法类</td>
<td>class</td>
<td>extends Operation</td>
</tr>
<tr>
<td>OperationFactory</td>
<td>运算工厂类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>SimpleFactoryMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>简单工厂模式：专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。简单工厂模式属于创建型模式又叫做静态工厂方法模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。</p>
<h4 id="2-策略模式-商场促销">2. 策略模式-----商场促销</h4>
<pre><code>package strategy_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>BaseCharge</td>
<td>收费算法类</td>
<td>abstract class</td>
<td>---</td>
</tr>
<tr>
<td>DiscountCharge</td>
<td>打折收费类</td>
<td>class</td>
<td>extends BaseCharge</td>
</tr>
<tr>
<td>NormalCharge</td>
<td>正常收费（无折扣）</td>
<td>class</td>
<td>extends BaseCharge</td>
</tr>
<tr>
<td>ReturnCharge</td>
<td>返利收费</td>
<td>class</td>
<td>extends BaseCharge</td>
</tr>
<tr>
<td>TypeEnum</td>
<td>收费折扣类型</td>
<td>enum</td>
<td>---</td>
</tr>
<tr>
<td>ChargeContext</td>
<td>策略算法上下文引用</td>
<td>class</td>
<td>----</td>
</tr>
<tr>
<td>StrategyMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>策略模式：它定义了算法家族，分别分装起来，让他们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。</p>
<h4 id="3装饰模式-穿衣系统">3.装饰模式-----穿衣系统</h4>
<pre><code>package decorator_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Component</td>
<td>公共抽象类</td>
<td>abstract class</td>
<td>---</td>
</tr>
<tr>
<td>Decorator</td>
<td>装饰类</td>
<td>class</td>
<td>extends Component</td>
</tr>
<tr>
<td>Persion</td>
<td>人物类</td>
<td>class</td>
<td>extends Component</td>
</tr>
<tr>
<td>BigTrouser</td>
<td>工裤类</td>
<td>class</td>
<td>extends Decorator</td>
</tr>
<tr>
<td>Sneaker</td>
<td>鞋子类</td>
<td>class</td>
<td>extends Decorator</td>
</tr>
<tr>
<td>TShirts</td>
<td>T恤类</td>
<td>class</td>
<td>extends Decorator</td>
</tr>
<tr>
<td>DecoratorMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>装饰模式：动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。</p>
<h4 id="4代理模式-送礼物">4.代理模式-----送礼物</h4>
<pre><code>package proxy_mode
</code></pre>
<p>代理模式：为其他对象提供一种代理以控制对这个对象的访问。</p>
<h5 id="a静态代理方式">a.静态代理方式</h5>
<pre><code>package proxy_mode.static_proxy_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>IGiveGift</td>
<td>送礼物接口</td>
<td>interface</td>
<td>---</td>
</tr>
<tr>
<td>Suitors</td>
<td>追求者</td>
<td>class</td>
<td>implements IGiveGift</td>
</tr>
<tr>
<td>Proxy</td>
<td>代理类</td>
<td>class</td>
<td>implements IGiveGift</td>
</tr>
<tr>
<td>StaticProxyMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<h5 id="bjdk动态代理方式">b.jdk动态代理方式</h5>
<pre><code>package proxy_mode.dynamic_proxy_mode.jdk_dynamic_proxy
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>IGiveGift</td>
<td>送礼物接口</td>
<td>interface</td>
<td>---</td>
</tr>
<tr>
<td>Suitors</td>
<td>追求者</td>
<td>class</td>
<td>implements IGiveGift</td>
</tr>
<tr>
<td>JdkProxy</td>
<td>代理类</td>
<td>class</td>
<td>implements InvocationHandler</td>
</tr>
<tr>
<td>JdkDynamicProxy</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<h5 id="ccglib动态代理方式">c.cglib动态代理方式</h5>
<pre><code>package proxy_mode.dynamic_proxy_mode.cglib_dynamic_proxy
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Suitors</td>
<td>追求者</td>
<td>class</td>
<td>implements IGiveGift</td>
</tr>
<tr>
<td>CglibProxy</td>
<td>代理类</td>
<td>class</td>
<td>implements MethodInterceptor</td>
</tr>
<tr>
<td>CglibDynamicProxy</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>需要导入<a href="https://mvnrepository.com/artifact/cglib/cglib/3.2.8">cglib-2.2.8.jar</a></p>
<h4 id="5-工厂模式-计算器">5. 工厂模式-----计算器</h4>
<pre><code>package factory_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Operation</td>
<td>运算类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>OperationAdd</td>
<td>加法类</td>
<td>class</td>
<td>extends Operation</td>
</tr>
<tr>
<td>OperationSub</td>
<td>减法类</td>
<td>class</td>
<td>extends Operation</td>
</tr>
<tr>
<td>OperationMul</td>
<td>乘法类</td>
<td>class</td>
<td>extends Operation</td>
</tr>
<tr>
<td>OperationDiv</td>
<td>除法类</td>
<td>class</td>
<td>extends Operation</td>
</tr>
<tr>
<td>IFactory</td>
<td>运算工厂接口</td>
<td>interface</td>
<td>---</td>
</tr>
<tr>
<td>AddFactory</td>
<td>加法工厂类</td>
<td>class</td>
<td>implements IFactory</td>
</tr>
<tr>
<td>SubFactory</td>
<td>减法工厂类</td>
<td>class</td>
<td>implements IFactory</td>
</tr>
<tr>
<td>MulFactory</td>
<td>乘法工厂类</td>
<td>class</td>
<td>implements IFactory</td>
</tr>
<tr>
<td>DivFactory</td>
<td>除法工厂类</td>
<td>class</td>
<td>implements IFactory</td>
</tr>
<tr>
<td>FactoryMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>工厂模式：定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。</p>
<p>相比简单工厂模式，工厂模式遵循开放-封闭原则，但增加了开发量。</p>
<h4 id="6-原型模式-印简历">6. 原型模式-----印简历</h4>
<h5 id="a浅拷贝">a.浅拷贝</h5>
<pre><code>package prototype_mode.shallow_copy_model
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Resume</td>
<td>简历类</td>
<td>class</td>
<td>implements Cloneable</td>
</tr>
<tr>
<td>Address</td>
<td>地址类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>PrototypeMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<h5 id="b深拷贝-1">b.深拷贝-1</h5>
<pre><code>package prototype_mode.deep_copy_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Resume_1</td>
<td>简历类</td>
<td>class</td>
<td>implements Cloneable</td>
</tr>
<tr>
<td>Address_1</td>
<td>地址类</td>
<td>class</td>
<td>implements Cloneable</td>
</tr>
<tr>
<td>PrototypeMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<h5 id="c深拷贝-2">c.深拷贝-2</h5>
<pre><code>package prototype_mode.deep_copy_mode2
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Resume_2</td>
<td>简历类</td>
<td>class</td>
<td>implements Cloneable</td>
</tr>
<tr>
<td>Address_2</td>
<td>地址类</td>
<td>class</td>
<td>implements Serializable</td>
</tr>
<tr>
<td>PrototypeMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>浅拷贝</strong>：对值类型的成员变量进行值的复制,对引用类型的成员变量仅仅复制引用,不复制引用的对象。</li>
<li><strong>深拷贝</strong>：对值类型的成员变量进行值的复制,对引用类型的成员变量也进行引用对象的复制。</li>
</ul>
<p>原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<h4 id="7-模板方法模式-抄试题">7. 模板方法模式-----抄试题</h4>
<pre><code>package template_method_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>BaseTestPaper</td>
<td>黑板试卷类</td>
<td>abstract class</td>
<td>---</td>
</tr>
<tr>
<td>TestPaperA</td>
<td>手抄试卷A类</td>
<td>class</td>
<td>extends BaseTestPaper</td>
</tr>
<tr>
<td>TestPaperA</td>
<td>手抄试卷B类</td>
<td>class</td>
<td>extends BaseTestPaper</td>
</tr>
<tr>
<td>TemplateMethodMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>模板方法模式：定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>模板方法模式实现了很好的代码复用性。</p>
<h4 id="8-外观模式-炒股票">8. 外观模式-----炒股票</h4>
<pre><code>package facade_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Stock</td>
<td>股票类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Realty</td>
<td>房地产类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>NationalDebt</td>
<td>国债类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Fund</td>
<td>基金类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>FacadeMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>外观模式：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p>完美体现了依赖倒转原则和迪米特法则的思想。</p>
<h4 id="9-建造者模式-产品生产线">9. 建造者模式-----产品生产线</h4>
<pre><code>package builder_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>BaseBuilder</td>
<td>建造者抽象类</td>
<td>abstract class</td>
<td>---</td>
</tr>
<tr>
<td>ConcreteBuilder1</td>
<td>具体建造者类1</td>
<td>class</td>
<td>extends BaseBuilder</td>
</tr>
<tr>
<td>ConcreteBuilder2</td>
<td>具体建造者类2</td>
<td>class</td>
<td>extends BaseBuilder</td>
</tr>
<tr>
<td>Product</td>
<td>产品类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Director</td>
<td>指挥者类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>BuilderMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<h4 id="10-观察者模式-员工偷懒">10. 观察者模式-----员工偷懒</h4>
<pre><code>package observer_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>BaseObserver</td>
<td>抽象观察者</td>
<td>abstract class</td>
<td>---</td>
</tr>
<tr>
<td>BaseSubject</td>
<td>抽象通知者</td>
<td>abstract class</td>
<td>---</td>
</tr>
<tr>
<td>Boss</td>
<td>老板类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Employee</td>
<td>员工类</td>
<td>class</td>
<td>extends BaseObserver</td>
</tr>
<tr>
<td>Reception</td>
<td>前台类</td>
<td>class</td>
<td>extends BaseSubject</td>
</tr>
<tr>
<td>ObserverMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>观察者模式：该模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p>
<h4 id="11-抽象工厂模式反射-切换db源">11. 抽象工厂模式+反射-----切换DB源</h4>
<pre><code>package abstract_factory_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>IUser</td>
<td>操作用户接口</td>
<td>interface</td>
<td>---</td>
</tr>
<tr>
<td>IDepartment</td>
<td>操作部门接口</td>
<td>interface</td>
<td>---</td>
</tr>
<tr>
<td>User</td>
<td>用户实体</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Department</td>
<td>部门实体</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>MySqlUser</td>
<td>mysql数据源-User</td>
<td>class</td>
<td>implements IUser</td>
</tr>
<tr>
<td>MySqlDepartment</td>
<td>mysql数据源-Department</td>
<td>class</td>
<td>implements IUser</td>
</tr>
<tr>
<td>SqlServerUser</td>
<td>sqlserver数据源-User</td>
<td>class</td>
<td>implements IDepartment</td>
</tr>
<tr>
<td>SqlServerDepartment</td>
<td>sqlserver数据源-Department</td>
<td>class</td>
<td>implements IDepartment</td>
</tr>
<tr>
<td>DBEnum</td>
<td>反射-全限定名</td>
<td>enum</td>
<td>---</td>
</tr>
<tr>
<td>DataSourceFactory</td>
<td>数据源切换工厂</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>AbstractFactoryMode</td>
<td>启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>注意:<a href="https://blog.csdn.net/jerry11112/article/details/80618420">简单工厂、抽象工厂和抽象工厂模式的区别</a>。</p>
<h4 id="12-状态模式-工作状态">12. 状态模式-----工作状态</h4>
<pre><code>package state_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>State</td>
<td>状态抽象类</td>
<td>abstract</td>
<td>---</td>
</tr>
<tr>
<td>Work</td>
<td>工作类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>ForenoonStare</td>
<td>上午工作状态类</td>
<td>class</td>
<td>extends State</td>
</tr>
<tr>
<td>NoonState</td>
<td>中午工作状态类</td>
<td>class</td>
<td>extends State</td>
</tr>
<tr>
<td>AfternoonState</td>
<td>下午工作状态类</td>
<td>class</td>
<td>extends State</td>
</tr>
<tr>
<td>EveningState</td>
<td>晚间工作状态</td>
<td>class</td>
<td>extends State</td>
</tr>
<tr>
<td>SleepingState</td>
<td>睡眠状态类</td>
<td>class</td>
<td>extends State</td>
</tr>
<tr>
<td>RestState</td>
<td>下班休息状态类</td>
<td>class</td>
<td>extends State</td>
</tr>
<tr>
<td>StateMode</td>
<td>状态模式启动类</td>
<td>class</td>
<td>extends State</td>
</tr>
</tbody>
</table>
<p>状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p>
<h4 id="13-适配器模式">13. 适配器模式</h4>
<pre><code>package adapter_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Target</td>
<td>客户期待的接口</td>
<td>interface</td>
<td>---</td>
</tr>
<tr>
<td>Adaptee</td>
<td>需要适配的类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Adapter</td>
<td>适配器类</td>
<td>class</td>
<td>implements Target</td>
</tr>
<tr>
<td>AdapterMain</td>
<td>适配器启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>适配器模式：将一个类的接口转换成客户希望的另一个接口。该模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<h4 id="14-备忘录模式">14. 备忘录模式</h4>
<pre><code>package memento_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Originator</td>
<td>发起人类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Memento</td>
<td>备忘录类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Caretaker</td>
<td>管理者类</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>MementoMode</td>
<td>备忘录模式启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态。这样以后就可以将该对象恢复到原先保存的状态。</p>
<h4 id="15-组合模式">15. 组合模式</h4>
<pre><code>package composite_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Component</td>
<td>对象默认接口</td>
<td>abstract</td>
<td>---</td>
</tr>
<tr>
<td>Composite</td>
<td>枝结点</td>
<td>class</td>
<td>extends Component</td>
</tr>
<tr>
<td>Leaf</td>
<td>叶子结点</td>
<td>class</td>
<td>extends Component</td>
</tr>
<tr>
<td>CompositeMode</td>
<td>组合模式启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>组合模式：将对象组成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<h4 id="16-迭代器模式">16. 迭代器模式</h4>
<pre><code>package iterator_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Iterator</td>
<td>迭代器抽象类</td>
<td>abstract</td>
<td>---</td>
</tr>
<tr>
<td>Aggregate</td>
<td>聚集抽象类</td>
<td>abstract</td>
<td>---</td>
</tr>
<tr>
<td>ConcreteIterator</td>
<td>正序迭代器类</td>
<td>class</td>
<td>extends Iterator</td>
</tr>
<tr>
<td>ConcreteIteratorDesc</td>
<td>逆序迭代器类</td>
<td>class</td>
<td>extends Iterator</td>
</tr>
<tr>
<td>ConcreteAggregate</td>
<td>具体聚集类</td>
<td>class</td>
<td>extends Aggregate</td>
</tr>
<tr>
<td>IteratorMode</td>
<td>迭代器模式启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。</p>
<h4 id="17-单例模式">17. 单例模式</h4>
<pre><code>package singleton_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Singleton1</td>
<td>懒汉式（线程不安全）</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Singleton2</td>
<td>懒汉式（线程安全，同步方法，不推荐使用）</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Singleton3</td>
<td>饿汉式（线程安全）</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Singleton4</td>
<td>静态内部类加载（线程安全）</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Singleton5</td>
<td>枚举（线程安全）</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Singleton6</td>
<td>懒汉式双重校验锁法（通常线程安全，不可保证完全安全）</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Singleton7</td>
<td>懒汉式双重检查终极版（面试手写推荐）</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Singleton8</td>
<td>使用 ThreadLocal 实现（线程安全）</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Singleton9</td>
<td>使用CAS 锁实现（线程安全）</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<pre><code>特点:
    1.一个类只允许产生一个实例化对象。
    2.单例类构造方法私有化，不允许外部创建对象。
    3.单例类向外提供静态方法，调用方法返回内部创建的实例化对象。
</code></pre>
<p><a href="https://mp.weixin.qq.com/s/-MShVr8txQ6nced-EhxAIg">资料来源</a></p>
<h4 id="18-桥接模式">18. 桥接模式</h4>
<pre><code>package bridge_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implementor</td>
<td>实现</td>
<td>abstract</td>
<td>---</td>
</tr>
<tr>
<td>ConcreteImplementorA</td>
<td>具体实现A</td>
<td>class</td>
<td>extends Implementor</td>
</tr>
<tr>
<td>ConcreteImplementorB</td>
<td>具体实现B</td>
<td>class</td>
<td>extends Implementor</td>
</tr>
<tr>
<td>Abstraction</td>
<td>抽象</td>
<td>abstract</td>
<td>---</td>
</tr>
<tr>
<td>RefinedAbstraction</td>
<td>被提炼的抽象</td>
<td>class</td>
<td>extends Abstraction</td>
</tr>
<tr>
<td>BridgeMode</td>
<td>桥接模式启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>桥接模式：将抽象部分与它的实现部分分离，使它们都可以独立的变化。</p>
<h4 id="19-命令模式">19. 命令模式</h4>
<pre><code>package command_mode
</code></pre>
<table>
<thead>
<tr>
<th>类名</th>
<th>释义</th>
<th>类型</th>
<th>依赖关系</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command</td>
<td>命令接口</td>
<td>abstract</td>
<td>---</td>
</tr>
<tr>
<td>ConcreteCommand</td>
<td>命令实现类</td>
<td>class</td>
<td>extends Command</td>
</tr>
<tr>
<td>Receiver</td>
<td>请求者</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>Invoker</td>
<td>要求执行者</td>
<td>class</td>
<td>---</td>
</tr>
<tr>
<td>CommandMode</td>
<td>命令模式启动类</td>
<td>class</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>命令模式：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ FigureBed图床系统]]></title>
        <id>https://saowu.github.io/blog/IVwOk1Phb/</id>
        <link href="https://saowu.github.io/blog/IVwOk1Phb/">
        </link>
        <updated>2020-04-03T12:06:39.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Flask 个人图床</p>
</blockquote>
<p>👉<a href="http://118.89.237.69:8000">demo website</a><br>
👉<a href="https://github.com/saowu/FigureBed">GitHub</a></p>
<h4 id="功能支持">功能支持</h4>
<pre><code>1.支持多文件上传（set max=5）
2.支持导出上传记录（csv文件）
3.支持返回多种链接格式 （link, markdown, html, bbcode，removal）
4.可以通过removal链接自行删除图片文件
5.使用mysql数据库
6.支持拖动上传
</code></pre>
<h4 id="docker部署">Docker部署</h4>
<pre><code>#构建flask+gunicorn+gevent(+nginx)
$docker build -t saowu/figurebed:1.0 .
$docker run  -p 8000:8888 -v /home/myDataVolume:/home/myDataVolume -d saowu/figurebed:1.0

#构建nginx(cd /nginx)
$docker build -t saowu/nginx:1.0 .
$docker run --name nginx1 -p 80:80 -d saowu/nginx:1.0
</code></pre>
<h4 id="ui展示">UI展示</h4>
<p><img src="https://saowu.github.io/blog//post-images/1585915830120.png" alt="" loading="lazy"><br>
<img src="https://saowu.github.io/blog//post-images/1585915839679.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言程序集（76-80）]]></title>
        <id>https://saowu.github.io/blog/c-yu-yan-cheng-xu-ji-76-80/</id>
        <link href="https://saowu.github.io/blog/c-yu-yan-cheng-xu-ji-76-80/">
        </link>
        <updated>2020-04-03T06:10:45.000Z</updated>
        <content type="html"><![CDATA[<h3 id="76整数数值交换">76.整数数值交换</h3>
<pre><code>#include&lt;stdio.h&gt;
int main()
{   int a=1,b=2;
    a-=b;
    b+=a;
    a=b-a;
    printf(&quot;a=%d,b=%d&quot;,a,b);
    return 0;
}
</code></pre>
<h3 id="77将9个学生的考试成绩进行分段统计">77.将9个学生的考试成绩进行分段统计...</h3>
<pre><code>将9个学生的考试成绩进行分段统计，考试成绩放在a数组中，各分数段的人数存在b组中：成绩为60到69的人数
存到b［0］中，成绩为70到79的人数存到b［1］，成绩为80到89的人数存到b［2］，成绩为90到99的人数存到b［3
］，成绩为100的人数存到b［4］，成绩为60以下的人数存到b［5］中。请输出数组b中的数据。假设a数组中的整数
数据为：93 85 77 68 59 43 94 75 98。 要求程序简练，采用的分支语录中分支语句中支数尽量少。

#include&lt;stdio.h&gt;
int main()
{   int a[9]= {93,85,77,68,59,43,94,75,98},b[6]= {0},i;
    for(i=0; i&lt;9; i++)
        if(a[i]&lt;60)
            b[5]++;
        else
            b[(a[i]-60)/10]++;
    for(i=0; i&lt;6; i++)
        printf(&quot;%d&quot;,b[i]);
    return 0;
}
</code></pre>
<h3 id="78利用指针设计一个函数求字符串长度">78.利用指针设计一个函数，求字符串长度</h3>
<pre><code>int strlen(char *s) {
    char *p=s;
    while(*p)
        p++;
    return p-s;
}
</code></pre>
<h3 id="79不规则数组去重">79.不规则数组去重</h3>
<pre><code>(自己写的)
#include&lt;stdio.h&gt;
int main()
{   int a[]= {1,2,2,2,4,5,5,8,9,9};
    int i,j,n=10,z,m;
    for(i=0; i&lt;n; i++) {
        //更新数组长度，m必须每次全部平移后才能更新
        m=n;
        for(j=i+1,z=i+1; j&lt;m; j++)
            if(a[i]!=a[j]) {
                a[z++]=a[j];
            } else {
                //记录数组移除重复数量
                n--;
            }
    }

    for(int k=0; k&lt;n; k++)
        printf(&quot;%d&quot;,a[k]);
    return 0;
}

(老师写的)
#include&lt;stdio.h&gt;
int main()
{   int a[]= {1,2,2,2,2,4,5,5,8,9,9};
    int i,j,k,n=11;
    for(i=0; i&lt;n; i++) {
        for(j=i+1; j&lt;n;)
            if(a[i]==a[j]) {
                for(k=j+1; k&lt;n; k++)
                    a[k-1]=a[k];
                n--;
            } else {
                j++;
            }
    }

    for(int t=0; t&lt;n; t++)
        printf(&quot;%d&quot;,a[t]);
    return 0;
}
</code></pre>
<h3 id="80统计单词个数并记录最长单词长度p166">80.统计单词个数，并记录最长单词长度(p166)</h3>
<pre><code>#include&lt;stdio.h&gt;

int main()
{
    char string[81];
    int i,num=0,len=0,max=0;
    char c;
    gets(string);
    for(i=0; (c=string[i])!='\0'; i++)
        if(c==' ') {
            if(len&gt;max)
                max=len;
            len=0;
        }
        else if(len==0) {
            len++;
            num++;
        }
        else {
            len++;
        }

    printf(&quot;There are %d words ,The longest word is %d&quot;,num,max);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言程序集（61-75）]]></title>
        <id>https://saowu.github.io/blog/c-yu-yan-cheng-xu-ji-61-75/</id>
        <link href="https://saowu.github.io/blog/c-yu-yan-cheng-xu-ji-61-75/">
        </link>
        <updated>2020-04-03T06:09:50.000Z</updated>
        <content type="html"><![CDATA[<h3 id="61二维数组的指针的运用">61.二维数组的指针的运用</h3>
<pre><code>#include&lt;stdio.h&gt;
int main()
{   int m[4][3]= {{5,2,3},{4,5,6},{7,8,9},{10,11,12}};
    int i,j,*a=m,**p=&amp;a,(*b)[3]=m;
    
    printf(&quot;%d\n&quot;,*(*(b+2)+0));
    printf(&quot;%d&quot;,*(*p+6));
    return 0;
}
</code></pre>
<h3 id="62abcdefgabcdefg">62.&quot;<em><em><em><em>A</em>BC</em>DEF</em>G</em>****&quot;☞&quot;ABCDEFG*****&quot;</h3>
<pre><code>
#include &quot;stdio.h&quot;
int main() {
    char s[]=&quot;****A*BC*DEF*G*****&quot;,*t=s;
    int i,j;
    while(*t) {
        t++;
    }
    t--;
    while(*t=='*') {
        t--;
    }
    for(i=0,j=0; &amp;s[i]!=t; i++) {
        if(s[i]!='*')
            s[j++]=s[i];
    }
    while(*t) {
        s[j++]=*t++;
    }
    s[j]='\0';
    puts(s);
    return 0;
}

#include &quot;stdio.h&quot;
int main() {
    char s[]=&quot;****A*BC*DEF*G*****&quot;,*t=s;
    int i,j;
    while(*++t);
    while(*--t=='*');
    for(i=0,j=0; &amp;s[i]!=t; i++) {
        if(s[i]!='*') s[j++]=s[i];
    }
    while(*t) {
        s[j++]=*t++;
    }
    s[j]='\0';
    puts(s);
    return 0;
}
</code></pre>
<h3 id="63库函数strcmp">63.库函数strcmp()</h3>
<pre><code>
#include&lt;string.h&gt;
int strcmp ( char* src,char* dst)
{
    int ret = 0 ;
    while( !(ret = *src - *dst) &amp;&amp; *dst)
        ++src, ++dst;
    if ( ret &lt; 0 )
        ret = -1 ;
    else if ( ret &gt; 0 )
        ret = 1 ;
    return( ret );
}
</code></pre>
<h3 id="64int-p双重指针">64.int **p双重指针</h3>
<pre><code>
#include&lt;stdio.h&gt;
int main()
{
    int p[3][4]= {15,2,3,4,5,6,7,8,9};
    int *s=p;
    int **a=&amp;s;
    printf(&quot;%d\n&quot;,p);
    printf(&quot;%d\n&quot;,s);
    printf(&quot;%d&quot;,a);
    return 0;
}
</code></pre>
<h3 id="65折半插入排序自己实现">65.折半插入排序（自己实现）</h3>
<pre><code>1)升序
#include&lt;stdio.h&gt;
int insertsort(int a[],int n) {
    int bottom,mid,top,temp,i,j;
    for(i=1; i&lt;n; i++) {
        //bottom值为0,top值为被排序值前一位
        bottom=0;
        top=i-1;
        while(bottom&lt;=top) {
            mid=(bottom+top)/2;
            if(a[i]&gt;a[mid])
                bottom=mid+1;
            else
                top=mid-1;
        } 
        //当前mid为最接近被排序值的位，如果被排序值大于mid。则mid++
        if(a[i]&gt;a[mid])
            mid++;
        //mid以后到i-1整体后移一位，被排序值与a[mid]交换
        temp=a[i];
        for(j=i-1; j&gt;=mid; j--)
            a[j+1]=a[j];
        a[mid]=temp;
        //每次排序都打印（此处理解用）
        printf(&quot;i=%d,mid=%d\n&quot;,i,mid);
        for(int k=0; k&lt;n; k++)
            printf(&quot;%d &quot;,a[k]);
        printf(&quot;\n&quot;);
    }
}
int main()
{   int x[]= {23,7,823,586,2,1,6,11};
    insertsort(x,sizeof(x)/4);
    return 0;
}

2)降序
#include&lt;stdio.h&gt;
int insertsort(int a[],int n) {
    int bottom,mid,top,temp,i,j;
    for(i=1; i&lt;n; i++) {
        //bottom值为0,top值为被排序值前一位
        bottom=0;
        top=i-1;
        while(bottom&lt;=top) {
            mid=(bottom+top)/2;
            if(a[i]&gt;a[mid])
                top=mid-1;
            else
                bottom=mid+1;
            //当前mid为最接近被排序值的位，如果被排序值小于mid。则mid++
            if(a[i]&lt;a[mid])
                mid++;
        }
        //mid以后i-1全体后移一位，被排序值与a[mid]交换
        temp=a[i];
        for(j=i-1; j&gt;=mid; j--)
            a[j+1]=a[j];
        a[mid]=temp;
        //每次排序都打印（此处理解用）
        printf(&quot;i=%d,mid=%d\n&quot;,i,mid);
        for(int k=0; k&lt;n; k++)
            printf(&quot;%d &quot;,a[k]);
        printf(&quot;\n&quot;);
    }
}
int main() {
    int x[]= {23,7,823,586,2,1,6,11};
    insertsort(x,sizeof(x)/4);
    return 0;
}

3)老师实现(哨兵位)
#include&lt;stdio.h&gt;
int insertsort(int a[],int n) {
    int bottom,mid,top,i,j;
    for(i=2; i&lt;=n; i++) {
        //a[0]为空闲，作为哨兵是temp的作用,不参与排序
        a[0]=a[i];
        bottom=1;
        top=i-1;
        while(bottom&lt;=top) {
            mid=(bottom+top)/2;
            if(a[0]&gt;a[mid])
                bottom=mid+1;
            else
                top=mid-1;
        }
        for(j=i-1; j&gt;=top+1; j--)
            a[j+1]=a[j];
        a[top+1]=a[0];
        //每次排序都打印（从a[1]打印到a[n]）
        printf(&quot;\n&quot;);
        for(int k=1; k&lt;n+1; k++)
            printf(&quot;%d &quot;,a[k]);
        printf(&quot;\n&quot;);
    }
}
int main() {
    int x[]= {0,23,7,823,586,2,1,6,11};
    insertsort(x,sizeof(x)/4);
    return 0;
}
</code></pre>
<h3 id="66求自然对数e111121n">66.求自然对数e=1+1/1!+1/2!+…+1/n!</h3>
<pre><code>#include &lt;stdio.h&gt;
int main()
{
    long n = 0, ns = 1;
    double x=0.0, e = 1.0;
    while(1) {
        n++;
        ns *= n;
        x = 1.0 / ns;
        if (x &lt; 1e-8)
            break;
        e += x;
    }
    printf(&quot;%9.10f\n&quot;, e);
    return 0;
}

</code></pre>
<h3 id="67顺序插入排序法">67.顺序插入排序法</h3>
<pre><code>#include &quot;stdio.h&quot;
int main() {
    int c[]= {23,1,56,234,7,0,34},i,j,t;
    for(i=1; i&lt;7; i++) {
        t=c[i];
        j=i-1;
        while(j&gt;=0 &amp;&amp; t&gt;c[j]) {
            c[j+1]=c[j];
            j--;
        }
        c[j+1]=t;
    }
    for(i=0; i&lt;7; i++)
        printf(&quot;%d &quot;,c[i]);
    putchar('\n');
}
</code></pre>
<h3 id="68一个球自由100m落下每次反弹一半问第10次落地经过多少m最后一次反弹多高">68.一个球自由100m落下，每次反弹一半，问第10次落地经过多少m，最后一次反弹多高</h3>
<pre><code>
#include&lt;stdio.h&gt;
int fun(float m,int n) {
    if(n==0) {
        printf(&quot;m=%f\n&quot;,m);
        return 0;
    } else {
        return fun(m/2,n-1)+m;
    }
}
int main()
{
    int m,n,c;
    scanf(&quot;%d,%d&quot;,&amp;m,&amp;n);
    c=fun(m,n)+m;
    printf(&quot;c=%d&quot;,c);
    return 0;
}
</code></pre>
<h3 id="69计算字符串长度">69.计算字符串长度</h3>
<pre><code>#include&lt;stdio.h&gt;
int len(char * s) {
    char * p=s;
    while(*p++);
    return(p-s);
}
int main()
{
    int i=len(&quot;123456&quot;);
    printf(&quot;%d&quot;,i);
    return 0;
}
</code></pre>
<h3 id="70-库函数strstr源码">70. 库函数strstr()源码</h3>
<pre><code>#include&lt;stdio.h&gt;
char *strstr (char *str1,char *str2) {
    char *cp = str1;
    char *s1, *s2;
    if ( !*str2 )
        return(str1);
    while (*cp) {
        s1 = cp;
        s2 = str2;
        while ( *s1 &amp;&amp; *s2 &amp;&amp; !(*s1-*s2) )
            s1++, s2++;
        if (!*s2)
            return(cp);
        cp++;
    }
    return(NULL);
}
int main()
{
    char *p=strstr(&quot;a12345633258&quot;,&quot;56&quot;);
    printf(&quot;%s&quot;,p);
    return 0;
}
</code></pre>
<h3 id="71库函数strchr源码">71.库函数strchr()源码</h3>
<pre><code>#include&lt;stdio.h&gt;
char *strchr (char *string,int ch) {
    while (*string &amp;&amp; *string != (char)ch)
        string++;
    if (*string == (char)ch)
        return(string);
    return(NULL);
}
int main()
{
    char *p=strchr(&quot;123&quot;,'3');
    printf(&quot;%c&quot;,*p);
    return 0;
}
</code></pre>
<h3 id="72实型比较大小因为double和float精度不同所以直接判断有可能会判断失败">72.实型比较大小(因为double和float精度不同所以直接判断有可能会判断失败)</h3>
<pre><code>
#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
int main()
{   double a=1.0000000000000001;
    float b=1.0000000001;
    if(fabs(a-b)&gt;1e-8)
        printf(&quot;a&gt;b&quot;);
    else
        printf(&quot;a&lt;b&quot;);
    return 0;
}
</code></pre>
<h3 id="73读程序结果">73.读程序结果</h3>
<pre><code>
#include&lt;stdio.h&gt;
int main()
{   //四舍五入
    double x =1.234;
    printf(&quot;%.2f&quot;,x);
    return 0;
}
</code></pre>
<h3 id="74求π的近似值不同的方法近似度不同课本p131">74.求π的近似值,不同的方法近似度不同(课本p131)</h3>
<pre><code>
第①种  π/4=...

#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
double pi(double eps)
{
    double t=1.0,s=0.0;
    int n=1,i=0;

    while(fabs(t)&gt;=eps) {
        t=pow(-1,i)/(2*n-1);
        s+=t;
        i++;
        n++;
    }
    return s*4;
}
int main()
{
    //eps为精度控制
    double eps=1e-6;
    printf(&quot;%.6f\n&quot;,pi(eps));
    return 0;
}

#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
int main(){
    float s=1;
    float pi=0;
    float i=1.0;
    float n=1.0;
    while(fabs(i)&gt;=1e-6){
        pi+=i;
        n=n+2;
        s=-s; 
        i=s/n;
    }
    pi=4*pi;
    printf(&quot;pi的值为：%.6f\n&quot;,pi);
    return 0;
}

第②类 π/2=1+1/3+1/3*2/5+1/3*2/5*3/7+1/3*2/5*3/7*4/9+...

#include&lt;stdio.h&gt;
double pi(double eps)
{
    double s=0.0,t=1.0;
    int n;
    for(n=1; t&gt;=eps; n++) {
        s+=t;
        t=n*t/(2*n+1);
    }
    return 2*s;
}
int main()
{
    //eps为精度控制
    double eps=1e-6;
    printf(&quot;%0.6f\n&quot;,pi(eps));
    return 0;
}

第③种  π²/6=...  

#include&lt;stdio.h&gt;
#include&lt;math.h&gt;
double pi(double eps) {
    double s=0.0,t=1.0,n;
    for(n=1; t&gt;=eps; n++) {
        t=1/(n*n);
        s+=t;
    }
    return sqrt(6*s);
}
int main() {
    //eps为精度控制
    double eps=1e-6;
    printf(&quot;%0.6f\n&quot;,pi(eps));
    return 0;
}

</code></pre>
<h3 id="75读程序结果">75.读程序结果</h3>
<pre><code>#include &lt;stdio.h&gt;
#define PR(ar) printf(&quot;%d &quot;,ar);
main()
{
    int j, a[] = { 1, 3, 5, 7, 9, 11, 15 }, *p = a + 5;
    for (j = 3; j; j--)
        switch (j)
        {
        case 1:
        case 2:
            //*号的优先级很低
            PR(*p++);
            break;
        case 3:
            PR(*(--p));
        }
    printf(&quot;\n&quot;);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言程序集（46-60）]]></title>
        <id>https://saowu.github.io/blog/c-yu-yan-cheng-xu-ji-46-60/</id>
        <link href="https://saowu.github.io/blog/c-yu-yan-cheng-xu-ji-46-60/">
        </link>
        <updated>2020-04-03T06:08:20.000Z</updated>
        <content type="html"><![CDATA[<h3 id="46把数组元素依次向后移动一个位置">46.把数组元素依次向后移动一个位置</h3>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int a[11];
    for (int i = 0; i &lt;= 10; i++) {
        a[i] = i;
        printf(&quot;%d &quot;, a[i]);
    }
    printf(&quot;\n&quot;);
    for (int i = 10; i &gt;= 0; i--) {
        a[i] = a[i - 1];
    }
    for (int i = 0; i &lt;= 10; i++) {
        printf(&quot;%d &quot;, a[i]);
    }
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
0 1 2 3 4 5 6 7 8 9 10 
0 0 1 2 3 4 5 6 7 8 9 
Process finished with exit code 0

</code></pre>
<h3 id="47输入一组数据找出最大值">47.输入一组数据，找出最大值</h3>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int a[10], max;
    for (int i = 0; i &lt; 10; i++) {
        scanf(&quot;%d&quot;, &amp;a[i]);
    }
    max = a[0];
    for (int i = 1; i &lt; 10; i++) {
        if (max &lt; a[i])
            max = a[i];
    }
    printf(&quot;max=%d&quot;, max);
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
12
3
2
4
5
6
3453
123
1
1
max=3453
Process finished with exit code 0

</code></pre>
<h3 id="48输入一组数据颠倒之后再输出">48.输入一组数据，颠倒之后再输出</h3>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int a[10], t;
    for (int i = 0; i &lt; 10; i++) {
        scanf(&quot;%d&quot;, &amp;a[i]);
    }
    printf(&quot;原始顺序：\n&quot;);
    for (int i = 0; i &lt;= 9; i++) {
        printf(&quot;%d &quot;, a[i]);
    }
    for (int i = 0; i &lt; 9 / 2; i++) {
        t = a[i];
        a[i] = a[9 - i];
        a[9 - i] = t;
    }
    printf(&quot;\n交换之后的顺序：\n&quot;);
    for (int i = 0; i &lt;= 9; i++) {
        printf(&quot;%d &quot;, a[i]);
    }
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
1
2
3
4
5
6
7
8
9
0
原始顺序：
1 2 3 4 5 6 7 8 9 0 
交换之后的顺序：
0 9 8 7 5 6 4 3 2 1 
Process finished with exit code 0

</code></pre>
<h3 id="49冒泡排序">49.冒泡排序</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int a[10] = {9, 7, 2, 5, 4, 1}, t;
    for (int i = 0; i &lt; 5; i++) {
        for (int j = 0; j &lt; 5 - i; j++) {
            if (a[j] &gt; a[j + 1]) {
                t = a[j];
                a[j] = a[j + 1];
                a[j + 1] = t;
            }
        }
    }
    for (int i = 0; i &lt; 6; i++) {
        printf(&quot;%d &quot;, a[i]);
    }
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
1 2 4 5 7 9 
Process finished with exit code 0

</code></pre>
<h3 id="50选择排序">50.选择排序</h3>
<pre><code>
#include &lt;stdio.h&gt; 
#include &lt;math.h&gt;

int main() {
    int a[6] = {9, 7, 2, 5, 4, 1}, k, t;
    for (int i = 0; i &lt; 5; i++) {
        k = i;
        for (int j = k + 1; j &lt; 6; j++) {
            if (a[k] &gt; a[j]) {
                k = j;
            }
        }
        if (k != i) {
            t = a[i];
            a[i] = a[k];
            a[k] = t;
        }

    }
    for (int i = 0; i &lt; 6; i++) {
        printf(&quot;%d &quot;, a[i]);
    }
    return 0;
}


#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
int main() {
    int a[6] = {9, 7, 2, 5, 4, 1}, k, t;
    for (int i = 0; i &lt; 5; i++) {
        k = 0;
        for (int j =  1; j &lt; 6-i; j++) {
            if (a[k] &lt; a[j]) {
                k = j;
            }
        }
        if (k != 5-i) {
            t = a[5-i];
            a[5-i] = a[k];
            a[k] = t;
        }
        
    }
    for (int i = 0; i &lt; 6; i++) {
        printf(&quot;%d &quot;, a[i]);
    }
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
1 2 4 5 7 9 
Process finished with exit code 0

</code></pre>
<h3 id="51有一个已经排好序的数值要求输入一个数之后按原来排序的规律将他插入数组中">51.有一个已经排好序的数值，要求输入一个数之后，按原来排序的规律将他插入数组中</h3>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int a[9] = {10, 20, 30, 40, 50, 60, 70, 80}, x, p = 8;
    printf(&quot;输入要插入的数：&quot;);
    scanf(&quot;%d&quot;, &amp;x);
    for (int i = 0; i &lt; 8; i++) {
        if (x &lt; a[i]) {
            p = i;
            break;
        }
    }
    for (int i = 8; i &gt; p; i--) {
        a[i] = a[i - 1];
    }
    a[p] = x;
    for (int i = 0; i &lt; 9; i++) {
        printf(&quot;%d &quot;, a[i]);
    }
    return 0;
}
输入:
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
输入要插入的数：78
10 20 30 40 50 60 70 78 80 
Process finished with exit code 0

</code></pre>
<h3 id="52在数组中删除一个数">52.在数组中删除一个数</h3>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int a[8] = {10, 20, 30, 40, 50, 60, 70, 80}, x, j, i,flag=0;
    printf(&quot;输入要删除的数：&quot;);
    scanf(&quot;%d&quot;, &amp;x);
    for (i = 0, j = 0; i &lt; 8; i++) {
        if (a[i] != x) {
            a[j] = a[i];
            j++;
        }else{
            flag=1;
        }
    }
    if(flag==1)
        a[8-1]=0;
    for (int k = 0; k &lt; 8; k++) {
        printf(&quot;%d &quot;, a[k]);
    }
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
输入要删除的数：10
20 30 40 50 60 70 80 0 
Process finished with exit code 0

</code></pre>
<h3 id="53二维矩阵进行行列倒置">53.二维矩阵进行行列倒置</h3>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int a[3][4],b[4][3];
    for (int i = 0; i &lt;3 ; i++) {
        for (int j = 0; j &lt;4 ; j++) {
            scanf(&quot;%d&quot;,&amp;a[i][j]);
        }
    }
    for (int i = 0; i &lt;3 ; i++) {
        for (int j = 0; j &lt;4 ; j++) {
           b[j][i]=a[i][j];
        }
    }
    for (int i = 0; i &lt;3 ; i++) {
        for (int j = 0; j &lt;4 ; j++) {
            printf(&quot;%3d &quot;,a[i][j]);
        }
        printf(&quot;\n&quot;);
    }
    printf(&quot;\n&quot;);
    for (int i = 0; i &lt;4 ; i++) {
        for (int j = 0; j &lt;3 ; j++) {
            printf(&quot;%3d &quot;,b[i][j]);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
1
2
3
4
5
6
7
8
9
0
1
2
  1   2   3   4 
  5   6   7   8 
  9   0   1   2 

  1   5   9 
  2   6   0 
  3   7   1 
  4   8   2 

Process finished with exit code 0

</code></pre>
<h3 id="54找出矩阵最大值并输出行号和列号">54.找出矩阵最大值，并输出行号和列号</h3>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int a[3][4] = {{5,  2, 0,  9},
                   {3,  7, 12, 6},
                   {19, 4, 1,  8}}, max, col, row;
    for (int i = 0; i &lt; 3; i++) {
        for (int j = 0; j &lt; 4; j++) {
            if (a[i][j] &gt; max) {
                max = a[i][j];
                row = i;
                col = j;
            }
        }
    }
    printf(&quot;max=%d\n&quot;, max);
    printf(&quot;max=a[%d][%d]&quot;, row, col);

    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
max=19
max=a[2][0]
Process finished with exit code 0

</code></pre>
<h3 id="55折半查找">55.折半查找</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int a[6] = {-2, 3, 6, 8, 12, 15}, bottom, top, mid, x;
    scanf(&quot;%d&quot;, &amp;x);
    bottom = 0;
    top = 5;
    while (bottom &lt;= top) {
        mid = (bottom + top) / 2;
        if (a[mid] == x) {
            printf(&quot;Find! a[%d]=%d\n&quot;, mid, x);
            break;
        } else if (x &gt; a[mid]) {
            bottom = mid + 1;
        } else {
            top = mid - 1;
        }
    }
    if (bottom &gt; top)
        printf(&quot;No find!\n&quot;);

    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
-2
Find! a[0]=-2

Process finished with exit code 0

</code></pre>
<h3 id="56456789321">56.456789321</h3>
<pre><code>
#include&lt;stdio.h&gt;

int main()
{   int t;
    int a[9]= {1,2,3,4,5,6,7,8,9};
    for(int j=0; j&lt;4; j++) {
        t=a[0];
        for(int i=1; i&lt;9-j; i++) {
            a[i-1]=a[i];
        }
        a[9-j-1]=t;
    }
    for(int i=0; i&lt;9; i++)
        printf(&quot;%d&quot;,a[i]);
    return 0;
}

#include&lt;stdio.h&gt;
int main()
{
    int a[]= {1,2,3,4,5,6,7,8,9,0},i,j,t;
    for(i=0; i&lt;3; i++) {
        t=a[0];
        for(j=0; j&lt;10-i-2; j++)
            a[j]=a[j+1];
        a[10-i-2]=t;
    }
    for(i=0; i&lt;10; i++)
        printf(&quot;%d&quot;,a[i]);
    return 0;
}

</code></pre>
<h3 id="57进制转换">57.进制转换</h3>
<pre><code>
#include&lt;stdio.h&gt;

int converse(int n)
{
    int i=0;
    char a[20],b[]=&quot;0123456789ABCDEF&quot;;
    while(n) {
        a[i++]=b[n%16];
        n=n/16;
    }
    for(--i; i&gt;=0; i--)
        printf(&quot;%c&quot;,a[i]);
}
int main()
{
    converse(200);
    return 0;
}
</code></pre>
<h3 id="58打印杨辉三角">58.打印杨辉三角</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

const int length = 10;// 定义杨辉三角的大小
int main()
{
    int nums[length][length];
    int i, j;
    /*计算杨辉三角*/ 
    for(i=0; i&lt;length; i++)
    {
        nums[i][0] = 1;
        nums[i][i] = 1;
        for(j=1; j&lt;i; j++)
            nums[i][j] = nums[i-1][j-1] + nums[i-1][j];
    }

    /*打印输出*/ 
    for(i=0; i&lt;length; i++)
    {
        for(j=0; j&lt;length-i-1; j++)
            printf(&quot;   &quot;);
        for(j=0; j&lt;=i; j++)
            printf(&quot;%-5d &quot;, nums[i][j]);
        putchar('\n');
    }
}
</code></pre>
<h3 id="59字母加密解密">59.字母加密解密</h3>
<pre><code>加密:
#include&lt;stdio.h&gt;
#include&lt;ctype.h&gt;
int main()
{   char ch;
    while((ch=getchar())!='\n') {
        if(isupper(ch))
            ch=(ch-'A'+4)%26+'A';
        if(islower(ch))
            ch=(ch-'a'+4)%26+'a';
        printf(&quot;%c&quot;,ch);
    }
    return 0;
}
解密:
#include&lt;stdio.h&gt;
#include&lt;ctype.h&gt;
int main()
{   char ch;
    while((ch=getchar())!='\n') {
        if(isupper(ch))
            ch=(ch-'A'+22)%26+'A';
        if(islower(ch))
            ch=(ch-'a'+22)%26+'a';
        printf(&quot;%c&quot;,ch);
    }
    return 0;
}
</code></pre>
<h3 id="60递归二分查找">60.递归二分查找</h3>
<pre><code>#include&lt;stdio.h&gt;
int find(int n[],int x,int low,int high) {
    if(high&gt;=low) {
        int mid = (low + high)/2;
        if(x&gt;n[mid])
            return find(n,x,mid+1,high);
        else if(x&lt;n[mid])
            return find(n,x,low,mid-1);
        else
            return 1;
    } else {
        return 0;
    }
}
int main() {
    int a[]= {1,2,4,5,8,9,10};
    printf(&quot;%d&quot;,find(a,8,0,6));
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言程序集（31-45）]]></title>
        <id>https://saowu.github.io/blog/c-yu-yan-cheng-xu-ji-31-45/</id>
        <link href="https://saowu.github.io/blog/c-yu-yan-cheng-xu-ji-31-45/">
        </link>
        <updated>2020-04-03T06:07:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="31计算1-23-45-99-100">31.计算1-2+3-4+5-...+99-100=?</h3>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int sum = 0;
    for (int i = 1; i &lt;= 100; i++) {
        sum += pow(-1, i - 1) * i;
    }
    printf(&quot;sum=%d&quot;, sum);
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
sum=-50
Process finished with exit code 0

</code></pre>
<h3 id="32计算1112131100">32.计算1/1+1/2+1/3+...1/100=?</h3>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    float sum = 0;
    for (int i = 1; i &lt;= 100; i++) {
        sum += pow(i,-1);
    }
    printf(&quot;sum=%f&quot;, sum);
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
sum=5.187378
Process finished with exit code 0

</code></pre>
<h3 id="33计算1112131nn106">33.计算1/1+1/2+1/3+...+1/n=?,n=10^6</h3>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    float sum = 0;
    for (int i = 1; i &lt;= 1e6; i++) {
        sum += pow(i, -1);
    }
    printf(&quot;sum=%f&quot;, sum);
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
sum=14.357358
Process finished with exit code 0

</code></pre>
<h3 id="34输入两个整数m和n求其最大公约数和最小公倍数">34.输入两个整数m和n，求其最大公约数和最小公倍数</h3>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int m, n, r, p;
    printf(&quot;input m,n: &quot;);
    scanf(&quot;%d,%d&quot;, &amp;m, &amp;n);
    p = m * n;
    do {
        r = m % n;
        m = n;
        n = r;
    } while (r != 0);
    printf(&quot;最大公约数:%d\n&quot;, m);
    printf(&quot;最小公倍数:%d&quot;, p / m);
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
input m,n: 6,8
最大公约数:2
最小公倍数:24
Process finished with exit code 0

</code></pre>
<h3 id="35计算-222222222222222此时n5">35.计算 2+22+222+2222+22222=？(此时n=5)</h3>
<pre><code>
#include &lt;stdio.h&gt;

int main() {
    int n, s = 0, t = 0;
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; i++) {
        t = t * 10 + 2;
        s += t;
    }
    printf(&quot;%d\n&quot;, s);
    return 0;
} 
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
5
24690

Process finished with exit code 0



</code></pre>
<h3 id="36计算-21325385-求前20项">36.计算 2/1+3/2+5/3+8/5+... 求前20项</h3>
<pre><code>
#include &lt;stdio.h&gt;

int main() {
    float m = 2, n = 1, t, s = 0;
    for (int i = 1; i &lt;= 20; i++) {
        s += m / n;
        t = m;
        m += n;
        n = t;
    }
    printf(&quot;sum=%f\n&quot;, s);
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
sum=32.660263

Process finished with exit code 0

</code></pre>
<h3 id="37计算-12320">37.计算 1!+2!+3!+...+20!=?</h3>
<pre><code>
#include &lt;stdio.h&gt;

int main() {
    float s = 0, f = 1;
    for (int i = 1; i &lt;= 20; i++) {
        f *= i;
        s += f;
    }
    printf(&quot;sum=%f\n&quot;, s);
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
sum=2561327455189073920.000000

Process finished with exit code 0

</code></pre>
<h3 id="38计算">38.计算</h3>
<pre><code class="language-math"> \sum_{k=1}^{100}{k}+\sum_{k=1}^{50}{k^2}+\sum_{k=1}^{10}\frac{1}{k}=?
</code></pre>
<pre><code>#include &lt;stdio.h&gt;

int main() {
    int s1 = 0, s2 = 0;
    float s3 = 0;
    for (int i = 1; i &lt;= 100; i++)
        s1 += i;
    for (int i = 1; i &lt;= 50; i++)
        s2 += i * i;
    for (int i = 1; i &lt;= 10; i++)
        s3 += 1.0 / i;
    printf(&quot;%f&quot;, s1 + s2 + s3);
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
47977.929688
Process finished with exit code 0

</code></pre>
<h3 id="39水仙花数一个3位数各位数字的立方和等于它本身如153打印全部水仙花数">39.水仙花数：一个3位数，各位数字的立方和等于它本身（如：153）,打印全部水仙花数</h3>
<pre><code>1).
    #include &lt;stdio.h&gt;
    #include &lt;math.h&gt;
    
    int main() {
        int x, y, z, s;
        for (int m = 100; m &lt; 1000; m++) {
            x = m / 100;
            y = m / 10 % 10;
            z = m % 10;
            s = pow(x, 3) + pow(y, 3) + pow(z, 3);
            if (m == s)
                printf(&quot;%d is a water flower number.\n&quot;, m);
        }
        return 0;
    }
2).
    #include &lt;stdio.h&gt;
    #include &lt;math.h&gt;
    
    int main() {
        int x, s;
        for (int m = 1; m &lt;= 9; m++)
            for (int i = 0; i &lt;= 9; i++)
                for (int j = 0; j &lt;= 9; j++) {
                    x = m * 100 + i * 10 + j;
                    s = pow(m, 3) + pow(i, 3) + pow(j, 3);
                    if (x == s)
                        printf(&quot;%d is a water flower number.\n&quot;, x);
                }
        return 0;
    }
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
153 is a water flower number.
370 is a water flower number.
371 is a water flower number.
407 is a water flower number.

Process finished with exit code 0

</code></pre>
<h3 id="40如果一个数恰好等于它的因子之和这个数为完数例如6123找出1000以内的完数按照6-its-factors-are-1-2-3-格式打印">40.如果一个数恰好等于它的因子之和，这个数为“完数”（例如:6=1+2+3），找出1000以内的完数，按照:“6 its factors are 1 2 3” 格式打印</h3>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
int main() {
    int s;
    for (int i = 1; i &lt;= 1000; i++) {
        s = 0;
        for (int j = 1; j &lt;= i / 2; j++)
            if (i % j == 0)
                s += j;
        if (s == i) {
            printf(&quot;%d it's factors are &quot;, i);
            for (int j = 1; j &lt;= i / 2; j++) {
                if (i % j == 0)
                    printf(&quot;%d &quot;, j);
            }
            printf(&quot;\n&quot;);
        }
    }
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
6 its factors are 1 2 3 
28 its factors are 1 2 4 7 14 
496 its factors are 1 2 4 8 16 31 62 124 248 

Process finished with exit code 0


</code></pre>
<h3 id="41一个球从100m的高度落下每次落地后反跳回原高度的一半再落下再反弹-求它第10次落地时共经过多少米第10次反弹多高">41.一个球从100m的高度落下，每次落地后反跳回原高度的一半，再落下，再反弹。求它第10次落地时，共经过多少米，第10次反弹多高</h3>
<pre><code>

#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    float sum = 100, high = 50;
    for (int i = 0; i &lt; 10; i++) {
        sum += 2 * high;
        high /= 2;
    }
    printf(&quot;sum=%.2f,high=%f\n&quot;, sum, high*2);
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
sum=299.90,high=0.024414

Process finished with exit code 0

</code></pre>
<h3 id="42谭浩强c语言课本p141猴子吃桃">42.（谭浩强c语言课本P141）猴子吃桃</h3>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int x1, x2 = 1;
    for (int day = 9; day &gt;= 1; day--) {
        x1 = 2 * (x2 + 1);
        x2 = x1;
    }
    printf(&quot;num=%d\n&quot;, x1);
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
num=1534

Process finished with exit code 0

</code></pre>
<h3 id="43每个月兔子的总和依次为11235813这就是斐波那契数列">43.每个月兔子的总和依次为1，1，2，3，5，8，13...这就是斐波那契数列</h3>
<pre><code>{
    f1=1(n=1);
    f2=1(n=2);
    fn=f(n-1)+f(n-2)(n&gt;=3);
}

#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int f1 = 1, f2 = 1, f;
    printf(&quot;%5d %5d&quot;, f1, f2);
    for (int i = 3; i &lt;= 20; i++) {
        f = f1 + f2;
        printf(&quot;%5d &quot;, f);
        if (i % 5 == 0)
            printf(&quot;\n&quot;);
        f1 = f2;
        f2 = f;
    }
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
    1     1    2     3     5 
    8    13    21    34    55 
   89   144   233   377   610 
  987  1597  2584  4181  6765 

Process finished with exit code 0


</code></pre>
<h3 id="44判断一个数是否为素数">44.判断一个数是否为素数</h3>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int m, i;
    scanf(&quot;%d&quot;, &amp;m);
    for (i = 2; i &lt;= m / 2; i++)
        if (m % i == 0)
            break;
    if (m/2 == i-1)
        printf(&quot;Yes&quot;);
    else
        printf(&quot;No&quot;);
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
5
Yes
Process finished with exit code 0

</code></pre>
<h3 id="45成绩平均值">45.成绩平均值</h3>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int sum = 0, s[10];
    float ave;
    for (int i = 0; i &lt;= 9; i++) {
        scanf(&quot;%d&quot;, &amp;s[i]);
        sum += s[i];
    }
    ave = sum / 10.0;
    printf(&quot;ave=%f\n&quot;, ave);
    for (int j = 0; j &lt; 10; j++) {
        printf(&quot;%d&quot;, s[j]);
    }
    return 0;
}

输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
1
2
3
4
5
6
7
8
9
0
ave=4.500000
1234567890
Process finished with exit code 0


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言程序集（16-30）]]></title>
        <id>https://saowu.github.io/blog/c-yu-yan-cheng-xu-ji-16-30/</id>
        <link href="https://saowu.github.io/blog/c-yu-yan-cheng-xu-ji-16-30/">
        </link>
        <updated>2020-04-03T06:06:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="16打印的1010矩阵">16.打印<code>*</code>的10*10矩阵</h3>
<pre><code>
#include &lt;stdio.h&gt;
int main() {
    for (int i = 0; i &lt; 10; i++){
        for (int j = 0; j &lt; 10; j++)
            putchar('*');
        putchar('\n');
    }
    return 0;
}

输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
**********
**********
**********
**********
**********
**********
**********
**********
**********
**********

Process finished with exit code 0

</code></pre>
<h3 id="17打印">17.打印:</h3>
<pre><code>        *
        **
        ***
        ****
        *****

#include &lt;stdio.h&gt;
int main() {
    for (int i = 1; i &lt;= 5; i++) {
        for (int j = 1; j &lt;= i; j++)
            putchar('*');
        putchar('\n');
    }
    return 0;
}
</code></pre>
<h3 id="18打印">18.打印：</h3>
<pre><code>        *****
        ****
        ***
        **
        *
        
#include &lt;stdio.h&gt;
int main() {
    for (int i = 1; i &lt;= 5; i++) {
        for (int j = 5; j &gt;= i; j--)
            putchar('*');
        putchar('\n');
    }
    return 0;
}


</code></pre>
<h3 id="19打印">19.打印：</h3>
<pre><code>            *
            ***
            *****
            *******
            *********
            
#include &lt;stdio.h&gt;
int main() {
    for (int i = 1; i &lt;= 5; i++) {
        for (int j = 1; j &lt;= 2 * i - 1; j++)
            putchar('*');
        putchar('\n');
    }
    return 0;
}
</code></pre>
<h3 id="20打印">20.打印：</h3>
<pre><code>            *
           ***
          *****
         *******
        *********
        
#include &lt;stdio.h&gt;
int main() {
    for (int i = 1; i &lt;= 5; i++) {
        for (int j = 1; j &lt;= 5 - i; j++)
            putchar(' ');
        for (int j = 1; j &lt;= 2 * i - 1; j++)
            putchar('*');
        putchar('\n');
    }
    return 0;
}
</code></pre>
<h3 id="21打印">21.打印：</h3>
<pre><code>        *********
         *******
          *****
           ***
            *
            
#include &lt;stdio.h&gt;
int main() {
    for (int i = 5; i &gt;= 1; i--) {
        for (int j = 1; j &lt;= 5 - i; j++)
            putchar(' ');
        for (int j = 1; j &lt;= 2 * i - 1; j++)
            putchar('*');
        putchar('\n');
    }
    return 0;
}
</code></pre>
<h3 id="22打印">22.打印：</h3>
<pre><code>        *********
         *******
          *****
           ***
            *
           ***
          *****
         *******
        *********
        
#include &lt;stdio.h&gt;
int main() {
    for (int i = 5; i &gt;= 1; i--) {
        for (int j = 1; j &lt;= 5 - i; j++)
            putchar(' ');
        for (int j = 1; j &lt;= 2 * i - 1; j++)
            putchar('*');
        putchar('\n');
    }
    for (int i = 2; i &lt;= 5; i++) {
        for (int j = 1; j &lt;= 5 - i; j++)
            putchar(' ');
        for (int j = 1; j &lt;= 2 * i - 1; j++)
            putchar('*');
        putchar('\n');
    }
    return 0;
}
</code></pre>
<h3 id="23打印">23.打印：</h3>
<pre><code>            *
           ***
          *****
         *******
        *********
         *******
          *****
           ***
            *
            
#include &lt;stdio.h&gt;
int main() {
    for (int i = 1; i &lt;= 5; i++) {
        for (int j = 1; j &lt;= 5 - i; j++)
            putchar(' ');
        for (int j = 1; j &lt;= 2 * i - 1; j++)
            putchar('*');
        putchar('\n');
    }
    for (int i = 4; i &gt;= 1; i--) {
        for (int j = 1; j &lt;= 5 - i; j++)
            putchar(' ');
        for (int j = 1; j &lt;= 2 * i - 1; j++)
            putchar('*');
        putchar('\n');
    }

    return 0;
}

</code></pre>
<h3 id="24打印乘法口诀表">24.打印乘法口诀表</h3>
<pre><code>
#include &lt;stdio.h&gt;
int main() {
    for (int i = 1; i &lt;= 9; i++) {
        for (int j = 1; j &lt;= i; j++)
            printf(&quot;\t%d*%d=%d&quot;, i, j, i * j);
        printf(&quot;\n&quot;);
    }
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
	1*1=1
	2*1=2	2*2=4
	3*1=3	3*2=6	3*3=9
	4*1=4	4*2=8	4*3=12	4*4=16
	5*1=5	5*2=10	5*3=15	5*4=20	5*5=25
	6*1=6	6*2=12	6*3=18	6*4=24	6*5=30	6*6=36
	7*1=7	7*2=14	7*3=21	7*4=28	7*5=35	7*6=42	7*7=49
	8*1=8	8*2=16	8*3=24	8*4=32	8*5=40	8*6=48	8*7=56	8*8=64
	9*1=9	9*2=18	9*3=27	9*4=36	9*5=45	9*6=54	9*7=63	9*8=72	9*9=81

Process finished with exit code 0

</code></pre>
<h3 id="25打印">25.打印:</h3>
<pre><code>           1   2   3   4
           5   6   7   8
           9  10  11  12
          13  14  15  16
          
#include &lt;stdio.h&gt;
int main() {
    for (int i = 1; i &lt;= 4; i++) {
        for (int j = 1; j &lt;= 4; j++)
            printf(&quot;%4d&quot;, (i - 1) * 4 + j);
        printf(&quot;\n&quot;);
    }
    return 0;
}

</code></pre>
<h3 id="26打印">26.打印：</h3>
<pre><code>           1   5   9  13
           2   6  10  14
           3   7  11  15
           4   8  12  16
           
#include &lt;stdio.h&gt;
int main() {
    for (int i = 1; i &lt;= 4; i++) {
        for (int j = 1; j &lt;= 4; j++)
            printf(&quot;%4d&quot;, (j - 1) * 4 + i);
        printf(&quot;\n&quot;);
    }
    return 0;
}

</code></pre>
<h3 id="27真题打印">27.(真题)打印：</h3>
<pre><code>          16  15  14  13
          12  11  10   9
           8   7   6   5
           4   3   2   1
           
#include &lt;stdio.h&gt;
int main() {
    for (int i = 4; i &gt;= 1; i--) {
        for (int j = 1; j &lt;= 4; j++)
            printf(&quot;%4d&quot;, i * 4 - (j - 1));
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
<h3 id="28素数的判断">28.素数的判断</h3>
<pre><code>1).
    #include &lt;stdio.h&gt;
    #include &lt;math.h&gt;
    
    int main() {
        int i, x;
        printf(&quot;input x :&quot;);
        scanf(&quot;%d&quot;, &amp;x);
        for (i = 2; i &lt;= sqrt(x); i++)
            if (x % i == 0)
                break;
        if (i &gt; sqrt(x))
            printf(&quot;%d is a prime number.\n&quot;, x);
        else
            printf(&quot;%d is not a prime number.\n&quot;, x);
        return 0;
    }
2).
    #include &lt;stdio.h&gt;
    #include &lt;math.h&gt;
    int main() {
        int i, x, flag = 1;
        printf(&quot;input x :&quot;);
        scanf(&quot;%d&quot;, &amp;x);
        for (i = 2; i &lt;= sqrt(x); i++)
            if (x % i == 0) {
                flag = 0;
                break;
            }
        if (flag == 1)
            printf(&quot;%d is a prime number.\n&quot;, x);
        else
            printf(&quot;%d is not a prime number.\n&quot;, x);
        return 0;
    }
    
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
input x :34
34 is not a prime number.

Process finished with exit code 0

</code></pre>
<h3 id="29打印100~200之间的素数">29.打印100~200之间的素数</h3>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() {
    int flag;
    for (int x = 100; x &lt;= 200; x++) {
    //for(int x = 101; x &lt;=199; x += 2){
        flag = 1;
        for (int i = 2; i &lt;= sqrt(x); i++)
            if (x % i == 0) {
                flag = 0;
                break;
            }
        if (flag == 1)
            printf(&quot;%d\t&quot;, x);
    }

    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
101	103	107	109	113	127	131	137	139	149	151	157	163	167	173	179	181	191	193	197	199	
Process finished with exit code 0

</code></pre>
<h3 id="30打印ascii码与字母">30.打印ASCII码与字母</h3>
<pre><code>
#include &lt;stdio.h&gt;

int main() {
    for (int ch = 'a'; ch &lt;= 'z'; ch++) {
        printf(&quot;%c=%d %c=%d &quot;, ch - 32, ch - 32, ch, ch);
    }
    return 0;
}
输出：
/Users/wuyanbo/Documents/ClionProject/cmake-build-debug/ClionProject
A=65 a=97 B=66 b=98 C=67 c=99 D=68 d=100 E=69 e=101 F=70 f=102 G=71 g=103 H=72 h=104 I=73 i=105 J=74 j=106 K=75 k=107 L=76 l=108 M=77 m=109 N=78 n=110 O=79 o=111 P=80 p=112 Q=81 q=113 R=82 r=114 S=83 s=115 T=84 t=116 U=85 u=117 V=86 v=118 W=87 w=119 X=88 x=120 Y=89 y=121 Z=90 z=122 
Process finished with exit code 0

</code></pre>
]]></content>
    </entry>
</feed>